<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ÏßÄÎèÑ_DEMO (No Backend)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script type="text/javascript"
          src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=evhib7m5a4&callback=initMap">
  </script>

  <style>
    /* ---------- Í∏∞Ï°¥ Ïä§ÌÉÄÏùº Ïú†ÏßÄ ---------- */
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Arial, sans-serif;
      background: #f5f5f7;
      color: #111827;
    }
    #app {
      display: flex; flex-direction: column; height: 100vh; position: relative;
    }

    #map { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; margin-top: 0; z-index: 0; }

    #sidebar {
      position: fixed; z-index: 20; background: white; box-shadow: 0 0 15px rgba(0,0,0,0.15);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      top: 0; bottom: 0; left: 0; width: 320px;
      transform: translateX(-100%); border-right: 1px solid #eee;
      display: flex; flex-direction: column;
    }
    #sidebar.active { transform: translateX(0); }

    @media (max-width: 768px) {
      #sidebar {
        top: auto; left: 0; right: 0; bottom: 0; width: 100%; height: 45vh;
        border-right: none; border-radius: 20px 20px 0 0; transform: translateY(100%);
      }
      #sidebar.active { transform: translateY(0); }
    }

    .sb-header {
      flex-shrink: 0; display: flex; justify-content: space-between; align-items: start;
      padding: 16px 20px; border-bottom: 1px solid #f3f4f6; background: white; border-radius: 20px 20px 0 0;
    }
    .sb-title { font-size: 17px; font-weight: 700; color: #111827; }
    .sb-close { border: none; background: none; font-size: 24px; color: #9ca3af; padding: 0; cursor: pointer; line-height: 1;}
    .sb-body { flex: 1; padding: 20px; overflow-y: auto; }
    .sb-row { margin-bottom: 10px; font-size: 14px; color: #374151; line-height: 1.5; }

    #floating-controls {
      position: fixed; right: 12px; bottom: 24px; z-index: 10;
      display: flex; flex-direction: column; gap: 8px; align-items: stretch; 
    }

    #legend {
      background: rgba(255,255,255,0.95); backdrop-filter: blur(4px);
      padding: 10px 12px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      font-size: 12px; min-width: 140px; box-sizing: border-box;
    }
    .lg-row { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
    .swatch { width: 10px; height: 10px; border-radius: 50%; display:inline-block; }
    .lg-title { font-weight:700; margin-bottom:6px; color: #4b5563; }

    #mode-toggle {
      display: flex; background: rgba(255,255,255,0.95); backdrop-filter: blur(4px);
      padding: 4px; border-radius: 99px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); box-sizing: border-box;
    }

    .seg-btn {
      flex: 1; justify-content: center; border: none; background: transparent;
      padding: 8px 0; border-radius: 99px; font-size: 12px; font-weight: 600;
      cursor: pointer; color: #6b7280; display: inline-flex; align-items: center; gap: 5px; transition: all 0.2s;
    }
    .seg-btn.active { background: #f3f4f6; color: #111827; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); }
    .seg-btn span.dot { width: 6px; height: 6px; border-radius: 50%; background: #22c55e; }
    .seg-btn#btn-eff span.dot { background: #8b5cf6; }

    #filter-control {
      position: fixed; left: 12px; bottom: 20px; z-index: 20;
      width: 40px; height: 40px; border-radius: 20px;
      background: rgba(255,255,255,0.95); backdrop-filter: blur(4px);
      color: #374151; box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      display: flex; align-items: center; overflow: hidden; white-space: nowrap;
      transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.2s, opacity 0.3s, transform 0.3s;
      cursor: pointer;
    }
    #filter-control.expanded { width: 220px; background: #fff; border-color: #d1d5db; }
    #filter-control.hidden-ui { opacity: 0; pointer-events: none; transform: translateX(-20px); }

    #filter-icon-wrapper {
      min-width: 40px; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; flex-shrink: 0;
    }
    #filter-slider-box {
      display: flex; align-items: center; gap: 8px; padding: 16px; opacity: 0; white-space: nowrap; transition: opacity 0.2s ease-in;
    }
    #filter-control.expanded #filter-slider-box { opacity: 1; }
    #time-slider { width: 100px; accent-color: #2563eb; cursor: pointer; }
    #filter-val-label { font-size: 13px; font-weight: 700; color: #2563eb; min-width: 36px; text-align: right; }

    .dot { width: 10px; height: 10px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: transform 0.1s; }
    .stop-dot { width: 8px; height: 8px; border-radius: 50%; border: 2px solid #fff; background: #1a73e8; box-shadow: 0 1px 3px rgba(0,0,0,0.3); }

    .station-root-dot {
      width: 10px; height: 10px; border-radius: 50%; background: white; border: 3px solid #111827;
      position: relative; box-sizing: content-box; box-shadow: 0 1px 3px rgba(0,0,0,0.3); pointer-events: none;
    }
    .station-label {
      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);
      padding: 4px 8px; border-radius: 6px; color: white; font-size: 11px; font-weight: 600;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3); white-space: nowrap; z-index: 20;
    }
    .station-label::after {
      content: ''; position: absolute; bottom: -4px; left: 50%; transform: translateX(-50%); border-width: 4px; border-style: solid;
    }
    .station-label.board { background: #2563eb; }
    .station-label.board::after { border-color: #2563eb transparent transparent transparent; }
    .station-label.drop { background: #ef4444; }
    .station-label.drop::after { border-color: #ef4444 transparent transparent transparent; }
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>

    <div id="sidebar">
      <div id="sidebar-content" style="height: 100%; display: flex; flex-direction: column;"></div>
    </div>

    <div id="floating-controls">
      <div id="legend">
        <div class="lg-title" id="legend-title">ÏÜåÏöîÏãúÍ∞Ñ (Î∂Ñ)</div>
        <div id="legend-rows"></div>
      </div>
      <div id="mode-toggle">
        <button id="btn-time" class="seg-btn active"><span class="dot"></span>ÏãúÍ∞Ñ</button>
        <button id="btn-eff" class="seg-btn"><span class="dot"></span>Ìö®Ïú®</button>
      </div>
    </div>

    <div id="filter-control">
      <div id="filter-icon-wrapper">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line>
        <line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line>
        <line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line>
        <line x1="17" y1="16" x2="23" y2="16"></line>
        </svg>
      </div>
      <div id="filter-slider-box">
        <span id="filter-val-label">Ï†ÑÏ≤¥</span>
        <input type="range" id="time-slider" min="5" max="60" step="5" value="60">
      </div>  
    </div>
  </div>

  <script>
    // ---------- 1. Í∏∞Î≥∏ ÏÑ§Ï†ï ----------
    const DEST = { lat: 37.563729, lng: 126.936898 }; 
    
    // [Ï§ëÏöî] Ïó¨Í∏∞Ïóê ODsay 'WEBÏö©' API Key (Service URI)
    const ODSAY_KEY = "oU72P97mHlqhG+UPuxw2LwURI"; 

    const DATA_URL = "data/data.json";

    const COLORS = ['#22c55e','#84cc16','#eab308','#f97316','#ef4444','#8b5cf6'];
    let MODE = 'time';
    let DATA = null;
    let EFF_BREAKS = null;

    let mapInstance = null;
    let POINTS = [];
    let markers = [];
    let clusterMarkers = [];
    let routePolylines = [];
    let stopMarkers = [];
    let selectedPoint = null; 
    let FILTER_LIMIT = 60; // 60Ïù¥Î©¥ 'Ï†ÑÏ≤¥'Î°ú Í∞ÑÏ£º

    const CLUSTER_THRESHOLD = 3000; 
    const CLUSTER_ZOOM_ON   = 15; 
    const MAX_SLIDER_VAL = 60;  

    const ICON_HOME = `
      <div style="
        width: 36px; height: 36px; background: #111827;
        border: 2px solid #fff; border-radius: 50%;
        display: flex; align-items: center; justify-content: center;
        box-shadow: 0 6px 12px rgba(0,0,0,0.3); cursor: pointer;
      ">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="white">
          <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
      </div>
    `;

    // ---------- 2. Ïú†Ìã∏Î¶¨Ìã∞ ----------
    function setStatus(text) { 
      console.log("Status:", text); 
    }
    function fmt(n, d=0) { return (n == null || n === '' || isNaN(+n)) ? '-' : (+n).toFixed(d); }
    function esc(s) { return String(s ?? '').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])); }

    function colorForTime(t) {
      if (t == null || isNaN(+t)) return '#9e9e9e';
      if (t <= 10) return COLORS[0]; if (t <= 15) return COLORS[1];
      if (t <= 20) return COLORS[2]; if (t <= 25) return COLORS[3];
      if (t <= 30) return COLORS[4]; return COLORS[5];
    }

    function colorForEff(eff) {
      if (eff == null || isNaN(+eff)) return '#9e9e9e';
      if (!EFF_BREAKS || EFF_BREAKS.length !== 4) return COLORS[5];
      const [q1,q2,q3,q4] = EFF_BREAKS;
      if (eff <= q1) return COLORS[0]; if (eff <= q2) return COLORS[1];
      if (eff <= q3) return COLORS[2]; if (eff <= q4) return COLORS[3];
      return COLORS[4];
    }

    function computeEffBreaks(geo) {
      const vals = [];
      for (const f of geo.features || []) {
        const v = Number(f.properties?.efficiency);
        if (!isNaN(v) && isFinite(v)) vals.push(v);
      }
      if (!vals.length) return null;
      vals.sort((a,b)=>a-b);
      const q = p => vals[Math.floor(p*(vals.length-1))];
      return [q(0.2), q(0.4), q(0.6), q(0.8)];
    }

    // ---------- 3. UI Ï†úÏñ¥ ----------
    function applyMode() {
      updateLegend();
      document.getElementById('btn-time').classList.toggle('active', MODE==='time');
      document.getElementById('btn-eff').classList.toggle('active',  MODE==='eff');
      updateVisibleMarkers();
    }

    function updateLegend() {
      const rows = document.getElementById('legend-rows');
      const title = document.getElementById('legend-title');
      rows.innerHTML = '';
      if (MODE === 'time') {
        title.textContent = 'ÏÜåÏöîÏãúÍ∞Ñ (Î∂Ñ)';
        const labels = ['0-10','10-15','15-20','20-25','25-30','30+'];
        COLORS.forEach((c, i) => {
          rows.innerHTML += `<div class="lg-row"><span class="swatch" style="background:${c}"></span><span>${labels[i]}</span></div>`;
        });
      } else {
        title.textContent = 'Ìö®Ïú®';
        const b = EFF_BREAKS || [];
        const labels = b.length===4 ? ['Îß§Ïö∞ Ï¢ãÏùå','Ï¢ãÏùå','Î≥¥ÌÜµ','ÎÇòÏÅ®','Îß§Ïö∞ ÎÇòÏÅ®'] : ['1','2','3','4','5'];
        const cols = [...COLORS].slice(0,5);
        cols.forEach((c, i) => {
          rows.innerHTML += `<div class="lg-row"><span class="swatch" style="background:${c}"></span><span>${labels[i]}</span></div>`;
        });
      }
    }

    function openSidebar(marker) {
      const filterCtrl = document.getElementById('filter-control');
      if (filterCtrl) filterCtrl.classList.add('hidden-ui');

      const p = marker.__props || {};
      const sidebar = document.getElementById('sidebar');
      const content = document.getElementById('sidebar-content');

      let rentDisplay = esc(p.rent || '-');
      if (p.rent && p.rent.includes('@')) {
        const parts = p.rent.split('@');
        if (parts.length === 2) {
          rentDisplay = `Î≥¥Ï¶ùÍ∏à ${esc(parts[0])} / ÏõîÏÑ∏ ${esc(parts[1])}`;
        }
      }

      const rideMode = (p.ride || '').toString().trim().toLowerCase();
      let routeDetailHtml = '';

      if (rideMode === 'walk' || rideMode === 'walk_only') {
        routeDetailHtml = `<span>üö∂ ÎèÑÎ≥¥ ${fmt(p.exp_time)}Î∂Ñ</span>`;
      } else {
        routeDetailHtml = `
            <span>üö∂ ${fmt(p.w1)}Î∂Ñ</span>
            <span style="color:#9ca3af">‚Üí</span>
            <span>üöå ${fmt(p.t1)}Î∂Ñ</span>
            <span style="color:#9ca3af">‚Üí</span>
            <span>üö∂ ${fmt(p.w2)}Î∂Ñ</span>
        `;
      }

      content.innerHTML = `
        <div class="sb-header">
          <div class="sb-title">${esc(p.name || 'Í±¥Î¨º Ï†ïÎ≥¥')}</div>
          <button class="sb-close" onclick="closeSidebar()">√ó</button>
        </div>
        <div class="sb-body">
          <div class="sb-row"><span style="background:#f3f4f6; padding:2px 6px; border-radius:4px; font-size:12px;">${esc(p.usage || 'Ïö©ÎèÑÎØ∏ÏÉÅ')}</span></div>
          <div class="sb-row"><b>Ï£ºÏÜå:</b> ${esc(p.address || '-')}</div>
          <div class="sb-row"><b>Í∞ÄÍ≤©:</b> ${rentDisplay} <span style="color:#9ca3af">|</span> <b>Î©¥Ï†Å:</b> ${fmt(p.area,1)}„é°</div>
          <hr style="border:0; border-top:1px solid #eee; margin:16px 0;">
          <div class="sb-row"><b>Ïù¥ÎèôÏàòÎã®:</b> ${esc(p.ride || 'Ï†ïÎ≥¥ ÏóÜÏùå')}</div>
          
          <div class="sb-row" style="display:flex; align-items:center; gap:4px; font-size:13px;">
            ${routeDetailHtml}
          </div>

          <div class="sb-row" style="margin-top:12px; font-size:16px; font-weight:600; color:#2563eb;">
             Î∞∞Ï∞®Í∞ÑÍ≤©ÏùÑ Í≥†Î†§Ìïú Í∏∞ÎåÄÏÜåÏöîÏãúÍ∞Ñ: ${fmt(p.exp_time)}Î∂Ñ
          </div>
            <div class="sb-row" style="color:#6b7280; font-size:12px;">
              Ìö®Ïú®ÏßÄÏàò: ${fmt(p.efficiency, 3)} (ÎÇÆÏùÑÏàòÎ°ù Ï¢ãÏùå)
        </div>
      `;
      sidebar.classList.add('active');
      window.currentMarker = marker;
    }

    function closeSidebar() {
      document.getElementById('sidebar').classList.remove('active');
      const filterCtrl = document.getElementById('filter-control');
      if (filterCtrl) filterCtrl.classList.remove('hidden-ui');
      clearRouteOverlays();
      if (selectedPoint) {
        selectedPoint = null;
        updateVisibleMarkers();
      }
    }
    
    function refreshRoute() {
      if (window.currentMarker) requestRoute(window.currentMarker);
    }

    function fitMapToBounds(coords) {
      if (!mapInstance || !coords || coords.length === 0) return;
      const bounds = new naver.maps.LatLngBounds();
      coords.forEach(p => bounds.extend(p));
      const winWidth = window.innerWidth;
      const winHeight = window.innerHeight;
      const isMobile = winWidth < 768;
      let topPad = 50, rightPad = 50, bottomPad = 50, leftPad = 50;

      if (isMobile) {
        const sheetHeight = winHeight * 0.45;
        bottomPad = Math.min(sheetHeight + 40, winHeight * 0.6); 
      } else {
        const sidebar = document.getElementById('sidebar');
        const isOpen = sidebar && sidebar.classList.contains('active');
        if (isOpen) {
          const targetPad = 320 + 50;
          leftPad = Math.min(targetPad, winWidth * 0.45);
        }
      }

      const currentCenter = mapInstance.getCenter();
      const currentZoom = mapInstance.getZoom();

      mapInstance.fitBounds(bounds, {
        top: topPad, right: rightPad, bottom: bottomPad, left: leftPad
      });
      
      const targetCenter = mapInstance.getCenter();
      const targetZoom = mapInstance.getZoom();

      mapInstance.setCenter(currentCenter);
      mapInstance.setZoom(currentZoom);
      mapInstance.morph(targetCenter, targetZoom);
    }

    function updateVisibleMarkers() {
      if (!mapInstance || !POINTS.length) return;
      const bounds = mapInstance.getBounds();
      const zoom = mapInstance.getZoom();
      if (!bounds) return;

      const viewportPoints = [];
      let activePt = null;
      const isFiltering = FILTER_LIMIT < MAX_SLIDER_VAL;

      for (const pt of POINTS) {
        const p = pt.props || {};
        const isSelected = selectedPoint && (pt.lat === selectedPoint.lat && pt.lng === selectedPoint.lng);
        if (isSelected) activePt = pt;

        if (!isSelected) {
            if (isFiltering && p.exp_time > FILTER_LIMIT) continue;
            if (MODE === 'eff') {
                if (p.exp_time > 30) continue;
                let monthlyRent = 0;
                if (p.rent && p.rent.toString().includes('@')) {
                    const parts = p.rent.toString().split('@');
                    if (parts.length > 1) {
                        monthlyRent = Number(parts[1]);
                    }
                }
                if (monthlyRent > 65) continue;
            }
        }
        if (bounds.hasLatLng(new naver.maps.LatLng(pt.lat, pt.lng))) {
          viewportPoints.push(pt);
        }
      }

      markers.forEach(m => m.setMap(null)); markers = [];
      clusterMarkers.forEach(c => c.setMap(null)); clusterMarkers = [];

      const pointsToCluster = viewportPoints.filter(pt => {
        if (!selectedPoint) return true;
        return pt.lat !== selectedPoint.lat || pt.lng !== selectedPoint.lng;
      });

      const useCluster = !isFiltering && (pointsToCluster.length > CLUSTER_THRESHOLD || zoom <= CLUSTER_ZOOM_ON);

      if (activePt) {
        const marker = new naver.maps.Marker({
          map: mapInstance,
          position: new naver.maps.LatLng(activePt.lat, activePt.lng),
          zIndex: 9999,
          icon: { content: ICON_HOME, anchor: new naver.maps.Point(18,18) }
        });
        marker.__props = activePt.props;
        marker.__coord = { lat: activePt.lat, lng: activePt.lng };
        naver.maps.Event.addListener(marker, 'click', () => {
           openSidebar(marker);
           requestRoute(marker);
        });
        markers.push(marker);
      }

      if (useCluster) {
        const proj = mapInstance.getProjection();
        const clusterMap = new Map();
        const gridSize = 80;

        for (const pt of pointsToCluster) {
          const latlng = new naver.maps.LatLng(pt.lat, pt.lng);
          const pixel = proj.fromCoordToOffset(latlng);
          const k = `${Math.floor(pixel.x/gridSize)}_${Math.floor(pixel.y/gridSize)}`;
          if (!clusterMap.has(k)) clusterMap.set(k, { pts:[], sumLat:0, sumLng:0 });
          const c = clusterMap.get(k);
          c.pts.push(pt); c.sumLat+=pt.lat; c.sumLng+=pt.lng;
        }

        clusterMap.forEach(c => {
          const count = c.pts.length;
          const center = new naver.maps.LatLng(c.sumLat/count, c.sumLng/count);
          if (count === 1) {
            createDotMarker(c.pts[0]);
          } else {
            const cm = new naver.maps.Marker({
              map: mapInstance,
              position: center,
              icon: {
                content: `<div style="width:32px;height:32px;background:#1f2937;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:12px;box-shadow:0 2px 5px rgba(0,0,0,0.3);">${count}</div>`,
                anchor: new naver.maps.Point(16,16)
              }
            });
            naver.maps.Event.addListener(cm, 'click', () => {
              const nextZoom = Math.min(mapInstance.getZoom() + 2, 17);
              mapInstance.morph(center, nextZoom);
            });
            clusterMarkers.push(cm);
          }
        });
      } else {
        pointsToCluster.forEach(pt => createDotMarker(pt));
      }
      const statusText = isFiltering ? `ÌïÑÌÑ∞: ${FILTER_LIMIT}Î∂Ñ Ïù¥ÎÇ¥ (${viewportPoints.length}Í∞ú)` : `Ï¥ù ${POINTS.length.toLocaleString()}Í∞ú / ÌôîÎ©¥ ${viewportPoints.length}Í∞ú`;
      setStatus(statusText); 
    }

    function createDotMarker(pt) {
      const props = pt.props || {};
      const color = (MODE === 'time') ? colorForTime(props.exp_time) : colorForEff(props.efficiency);
      
      const m = new naver.maps.Marker({
        map: mapInstance,
        position: new naver.maps.LatLng(pt.lat, pt.lng),
        icon: {
          content: `<div class="dot" style="background:${color};"></div>`,
          anchor: new naver.maps.Point(5,5)
        }
      });
      m.__props = props;
      m.__coord = { lat: pt.lat, lng: pt.lng };
      naver.maps.Event.addListener(m, 'click', () => {
        selectedPoint = { lat: pt.lat, lng: pt.lng };
        updateVisibleMarkers(); 
        openSidebar(m);
        requestRoute(m);
      });
      markers.push(m);
    }

    // ---------- 5. Í≤ΩÎ°ú Î°úÏßÅ (ÌîÑÎ°†Ìä∏ÏóîÎìú Îã®ÎèÖ Íµ¨ÌòÑ) ----------
    function clearRouteOverlays() {
      routePolylines.forEach(p => p.setMap(null)); routePolylines = [];
      stopMarkers.forEach(m => m.setMap(null)); stopMarkers = [];
    }

    function drawWalkOnlyRoute(originCoord) {
      if (!mapInstance) return;
      clearRouteOverlays();
      const destLatLng = new naver.maps.LatLng(DEST.lat, DEST.lng);
      const originLatLng = new naver.maps.LatLng(originCoord.lat, originCoord.lng);
      const poly = new naver.maps.Polyline({
        map: mapInstance, path: [originLatLng, destLatLng],
        strokeColor: '#111827', strokeOpacity: 0.8, strokeStyle: 'shortdash', strokeWeight: 2
      });
      routePolylines.push(poly);
      fitMapToBounds([originLatLng, destLatLng]);
    }

    // [ÌïµÏã¨] Î∞±ÏóîÎìú ÏóÜÏù¥ ODsay ÏßÅÏ†ë Ìò∏Ï∂ú (Î≤ÑÏä§ Îß§Ïπ≠ Î°úÏßÅ Ìè¨Ìï®)
    async function requestRoute(marker) {
      const p = marker.__props || {};
      const coord = marker.__coord || {}; 
      
      if ((p.ride || '').toLowerCase() === 'walk' || (p.ride || '').toLowerCase() === 'walk_only') {
        drawWalkOnlyRoute(coord);
        return;
      }
      setStatus("Í≤ΩÎ°ú Í≥ÑÏÇ∞ Ï§ë‚Ä¶ (Front-end Direct)");

      try {
        // 1. Í∏∏Ï∞æÍ∏∞ API Ìò∏Ï∂ú
        const searchUrl = `https://api.odsay.com/v1/api/searchPubTransPathT?SX=${coord.lng}&SY=${coord.lat}&EX=${DEST.lng}&EY=${DEST.lat}&OPT=0&SearchPathType=0&apiKey=${encodeURIComponent(ODSAY_KEY)}`;
        const searchRes = await fetch(searchUrl);
        const searchData = await searchRes.json();

        if (searchData.error) throw new Error(JSON.stringify(searchData.error));

        // 2. ÌååÏù¥Ïç¨Ïóê ÏûàÎçò 'ÏµúÏ†Å Í≤ΩÎ°ú ÏÑ†ÌÉù Î°úÏßÅ' JS Î≤ÑÏ†Ñ Ìò∏Ï∂ú
        const bestPath = selectPathForRideJS(searchData, p.ride, p.board, p.drop);
        if (!bestPath) {
             drawWalkOnlyRoute(coord);
             return;
        }

        // 3. ÎÖ∏ÏÑ† Í∑∏ÎûòÌîΩ Îç∞Ïù¥ÌÑ∞ Ìò∏Ï∂ú
        const mapObj = bestPath.info.mapObj;
        const laneUrl = `https://api.odsay.com/v1/api/loadLane?mapObject=0:0@${mapObj}&apiKey=${encodeURIComponent(ODSAY_KEY)}`;
        const laneRes = await fetch(laneUrl);
        const laneData = await laneRes.json();

        if (laneData.error) throw new Error(JSON.stringify(laneData.error));

        // 4. ÏßÄÎèÑÏóê Í∑∏Î¶¨Í∏∞
        drawRouteFromLane(laneData, coord, p); 

      } catch (e) {
        console.error("ODsay Error:", e);
        setStatus("Í≤ΩÎ°ú Ìò∏Ï∂ú Ïã§Ìå®: " + e.message);
        drawWalkOnlyRoute(coord);
      }
    }

    // [Î°úÏßÅ Ïù¥Ïãù] ÌååÏù¥Ïç¨Ïùò score_path_for_ride -> JS Íµ¨ÌòÑ
    function selectPathForRideJS(data, ride, board, drop) {
        if (!data.result || !data.result.path) return null;
        const paths = data.result.path;
        
        if (!ride && !board && !drop) return paths[0];

        let best = null; 

        paths.forEach(path => {
            let score = 0;
            const info = path.info;
            const totalTime = info.totalTime;
            const subPaths = path.subPath || [];

            // 1. ride (Î≤ÑÏä§ Î≤àÌò∏) Îß§Ïπ≠
            if (ride) {
                const rideNorm = norm(ride);
                for (const sp of subPaths) {
                    if (![1, 2].includes(sp.trafficType)) continue; 
                    const lanes = sp.lane || [];
                    for (const lane of lanes) {
                        const candidates = [];
                        if (lane.busNo) candidates.push(lane.busNo);
                        if (lane.name) candidates.push(lane.name);
                        
                        let hit = false;
                        for (const cand of candidates) {
                            if (rideNorm && norm(cand).includes(rideNorm)) {
                                score += 10;
                                hit = true;
                                break;
                            }
                        }
                        if (hit) break;
                    }
                }
            }

            // 2. Ï†ïÎ•òÏû• Îß§Ïπ≠
            const stationNames = [];
            subPaths.forEach(sp => {
                const list = sp.passStopList || {};
                const stations = list.stations || list.station || [];
                stations.forEach(st => stationNames.push(norm(st.stationName)));
            });

            if (board && stationNames.some(s => s.includes(norm(board)))) score += 5;
            if (drop && stationNames.some(s => s.includes(norm(drop)))) score += 5;

            // ÏµúÍ≥† Ï†êÏàò Í∞±Ïã†
            if (best === null || score > best.score || (score === best.score && totalTime < best.totalTime)) {
                best = { score, totalTime, path };
            }
        });

        return best ? best.path : paths[0];
    }

    function norm(s) {
        if (!s) return "";
        return String(s).replace(/[() Î≤à]/g, "").trim();
    }

    function drawRouteFromLane(data, originCoord, props) {
      if (!mapInstance) return;
      clearRouteOverlays();

      if (!data || !data.result || !Array.isArray(data.result.lane)) {
        drawWalkOnlyRoute(originCoord);
        return;
      }

      const result = data.result;
      const polyPaths = [];
      const stationLatLngs = [];
      const stationNames   = [];
      const allStations = [];
      
      let allPointsForBounds = [];
      const originLatLng = new naver.maps.LatLng(originCoord.lat, originCoord.lng);
      const destLatLng   = new naver.maps.LatLng(DEST.lat, DEST.lng);
      allPointsForBounds.push(originLatLng, destLatLng);

      let firstRoutePoint = null;
      let lastRoutePoint  = null;

      for (const lane of result.lane) {
        const sections = lane.section || [];
        for (const section of sections) {
          const graphPos = section.graphPos || [];
          const path = [];

          for (const gp of graphPos) {
            const x = Number(gp.x);
            const y = Number(gp.y);
            if (isNaN(x) || isNaN(y)) continue;
            const latlng = new naver.maps.LatLng(y, x);
            path.push(latlng);
            allPointsForBounds.push(latlng);

            if (!firstRoutePoint) firstRoutePoint = latlng;
            lastRoutePoint = latlng;
          }

          if (path.length >= 2) polyPaths.push(path);

          const stations = section.station || [];
          for (const st of stations) {
            const sx = Number(st.x);
            const sy = Number(st.y);
            if (isNaN(sx) || isNaN(sy)) continue;
            const latlng = new naver.maps.LatLng(sy, sx);
            stationLatLngs.push(latlng);
            stationNames.push(st.stationName || '');
            allStations.push({ latlng, name: st.stationName || '' });
          }
        }
      }

      for (const path of polyPaths) {
        const pl = new naver.maps.Polyline({
          map: mapInstance, path,
          strokeColor: '#2563eb', strokeWeight: 3, strokeOpacity: 0.9
        });
        routePolylines.push(pl);
      }

      for (let i = 0; i < stationLatLngs.length; i++) {
        const marker = new naver.maps.Marker({
          map: mapInstance, position: stationLatLngs[i],
          icon: { content: '<div class="stop-dot"></div>', anchor: new naver.maps.Point(4,4) },
          title: stationNames[i]
        });
        stopMarkers.push(marker);
      }

      let boardLatLng = firstRoutePoint; 
      let dropLatLng  = lastRoutePoint;
      let finalBoardName = (props?.board || '').trim();
      let finalDropName  = (props?.drop || '').trim();

      if (allStations.length) {
        if (finalBoardName) {
          const foundBoard = allStations.find(s => (s.name || '').includes(finalBoardName));
          if (foundBoard) {finalBoardName = foundBoard.name;}
        }
        if (finalDropName) {
          const rev = [...allStations].reverse();
          const foundDrop = rev.find(s => (s.name || '').includes(finalDropName));
          if (foundDrop) {finalDropName = foundDrop.name;}
        }
      }

      if (boardLatLng) {
        const walk1 = new naver.maps.Polyline({
          map: mapInstance, path: [originLatLng, boardLatLng],
          strokeColor: '#111827', strokeOpacity: 0.8, strokeStyle: [4, 6], strokeWeight: 2
        });
        routePolylines.push(walk1);
        const boardMarker = new naver.maps.Marker({
          map: mapInstance, position: boardLatLng, zIndex: 1000,
          icon: {
            content: `
                <div class="station-root-dot" style="border-color: #2563eb;">
                    <div class="station-label board">${finalBoardName} ÏäπÏ∞®</div>
                </div>
            `,
            anchor: new naver.maps.Point(8, 8)
          },
        });
        stopMarkers.push(boardMarker);
      }

      if (dropLatLng) {
        const walk2 = new naver.maps.Polyline({
          map: mapInstance, path: [dropLatLng, destLatLng],
          strokeColor: '#111827', strokeOpacity: 0.8, strokeStyle: [4, 6], strokeWeight: 2
        });
        routePolylines.push(walk2);
        const dropMarker = new naver.maps.Marker({
          map: mapInstance, position: dropLatLng, zIndex: 1000,
          icon: {
            content: `
                <div class="station-root-dot" style="border-color: #ef4444;">
                    <div class="station-label drop">${finalDropName} ÌïòÏ∞®</div>
                </div>
            `,
            anchor: new naver.maps.Point(8, 8)
          },
        });
        stopMarkers.push(dropMarker);
      }
      fitMapToBounds(allPointsForBounds);
      setStatus("Í≤ΩÎ°ú ÌëúÏãú ÏôÑÎ£å");
    }

    // ---------- 6. Î°úÎìú Î∞è Ï¥àÍ∏∞Ìôî ----------
    async function loadData() {
      try {
        const res = await fetch(DATA_URL);
        const json = await res.json();
        DATA = json;
        EFF_BREAKS = computeEffBreaks(DATA);
        POINTS = [];
        (DATA.features||[]).forEach(f => {
          if(f.geometry?.type==='Point') {
            const [lng, lat] = f.geometry.coordinates;
            const props = {...f.properties, lat, lng};
            if(props.exp_time && props.price_per_py_m && !props.efficiency) {
              props.efficiency = props.exp_time / props.price_per_py_m;
            }
            POINTS.push({lat, lng, props});
          }
        });
        applyMode();
      } catch(e) {
        console.error(e);
        setStatus("Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®");
      }
    }

    function initMap() {
      const map = new naver.maps.Map('map', {
        center: new naver.maps.LatLng(DEST.lat, DEST.lng),
        zoom: 14, scaleControl: false, logoControl: false, mapDataControl: false,
      });
      mapInstance = map;

      new naver.maps.Marker({
        map, position: new naver.maps.LatLng(DEST.lat, DEST.lng),
        title: 'ÎèÑÏÑúÍ¥Ä',
        icon: { content: '<div style="font-size:20px;">üè´</div>', anchor: new naver.maps.Point(10,10) }
      });

      naver.maps.Event.addListener(map, 'idle', updateVisibleMarkers);
      naver.maps.Event.addListener(map, 'click', () => { closeSidebar(); });

      document.getElementById('btn-time').addEventListener('click', ()=>{ MODE='time'; applyMode(); });
      document.getElementById('btn-eff').addEventListener('click', ()=>{ MODE='eff'; applyMode(); });

      const filterCtrl = document.getElementById('filter-control');
      const slider = document.getElementById('time-slider');
      const label = document.getElementById('filter-val-label');

      if (filterCtrl && slider) {
        filterCtrl.addEventListener('click', (e) => {
           if (e.target === slider) return;
           filterCtrl.classList.toggle('expanded');
        });
        slider.addEventListener('input', (e) => {
           const val = Number(e.target.value);
           FILTER_LIMIT = val; 
           label.textContent = (val === 60) ? 'Ï†ÑÏ≤¥' : `${val}Î∂Ñ`;
           updateVisibleMarkers();
        });
      }
      loadData();
    }
  </script>
</body>
</html>
