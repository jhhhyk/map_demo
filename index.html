<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ETA ì§€ë„ (Logic Restored)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script type="text/javascript"
          src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=evhib7m5a4&callback=initMap">
  </script>

  <style>
    /* ---------- ìŠ¤íƒ€ì¼ì€ ê¸°ì¡´ ì™„ì„±ë³¸ ìœ ì§€ ---------- */
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Arial, sans-serif;
      background: #f5f5f7;
      color: #111827;
    }
    #app {
      display: flex; flex-direction: column; height: 100vh; position: relative;
    }

    #map { position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; margin-top: 0; z-index: 0; }

    #sidebar {
      position: fixed; z-index: 20; background: white; box-shadow: 0 0 15px rgba(0,0,0,0.15);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      top: 0; bottom: 0; left: 0; width: 320px;
      transform: translateX(-100%); border-right: 1px solid #eee;
      display: flex; flex-direction: column;
    }
    #sidebar.active { transform: translateX(0); }

    @media (max-width: 768px) {
      #sidebar {
        top: auto; left: 0; right: 0; bottom: 0; width: 100%; height: 45vh;
        border-right: none; border-radius: 20px 20px 0 0; transform: translateY(100%);
      }
      #sidebar.active { transform: translateY(0); }
    }

    .sb-header {
      flex-shrink: 0; display: flex; justify-content: space-between; align-items: start;
      padding: 16px 20px; border-bottom: 1px solid #f3f4f6; background: white; border-radius: 20px 20px 0 0;
    }
    .sb-title { font-size: 17px; font-weight: 700; color: #111827; }
    .sb-close { border: none; background: none; font-size: 24px; color: #9ca3af; padding: 0; cursor: pointer; line-height: 1;}
    .sb-body { flex: 1; padding: 20px; overflow-y: auto; }
    .sb-row { margin-bottom: 10px; font-size: 14px; color: #374151; line-height: 1.5; }
    .sb-btn-action {
      width: 100%; padding: 12px; margin-top: 10px; background: #111827; color: white;
      border: none; border-radius: 8px; font-weight: 600; cursor: pointer;
    }

    #floating-controls {
      position: fixed;
      right: 12px; 
      bottom: 24px;
      z-index: 10;
  
      display: flex;
      flex-direction: column; 
      gap: 8px; /* ë²”ë¡€ì™€ í† ê¸€ ì‚¬ì´ ê°„ê²© */
  
      /* â˜… í•µì‹¬: ìì‹ ìš”ì†Œ(ë²”ë¡€, í† ê¸€)ì˜ ë„ˆë¹„ë¥¼ ì„œë¡œ ê°™ê²Œ(ê°€ì¥ ë„“ì€ ìª½ì—) ë§ì¶¤ */
      align-items: stretch; 
    }

    #legend {
      background: rgba(255,255,255,0.95); 
      backdrop-filter: blur(4px);
      padding: 10px 12px; 
      border-radius: 12px; /* ë‘¥ê·¼ ì‚¬ê°í˜• */
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      font-size: 12px; 
      min-width: 140px; /* ìµœì†Œ ë„ˆë¹„ ë³´ì¥ */
      box-sizing: border-box; /* íŒ¨ë”© í¬í•¨ ë„ˆë¹„ ê³„ì‚° */
    }
    .lg-row { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
    .swatch { width: 10px; height: 10px; border-radius: 50%; display:inline-block; }
    .lg-title { font-weight:700; margin-bottom:6px; color: #4b5563; }

    #mode-toggle {
      display: flex; /* ë‚´ë¶€ ë²„íŠ¼ë“¤ì„ ê°€ë¡œë¡œ ë°°ì¹˜ */
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(4px);
      padding: 4px; 
      border-radius: 99px; /* â˜… ì•Œì•½ ëª¨ì–‘ (ì™„ì „ ë‘¥ê¸€ê²Œ) */
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      box-sizing: border-box;
    }

    .seg-btn {
      flex: 1; 
      justify-content: center; /* í…ìŠ¤íŠ¸ ê°€ìš´ë° ì •ë ¬ */
  
      border: none; 
      background: transparent; 
      padding: 8px 0; /* ìœ„ì•„ë˜ ì—¬ë°±ë§Œ ì¤Œ (ì¢Œìš°ëŠ” flexë¡œ ìë™ ì¡°ì ˆ) */
      border-radius: 99px; /* ë²„íŠ¼ ìì²´ë„ ì•Œì•½ ëª¨ì–‘ */
      font-size: 12px; 
      font-weight: 600; 
      cursor: pointer; 
      color: #6b7280;
      display: inline-flex; 
      align-items: center; 
      gap: 5px; 
      transition: all 0.2s;
    }
    .seg-btn.active { background: #f3f4f6; color: #111827; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); } /* í™œì„± ìŠ¤íƒ€ì¼ ë¯¸ì„¸ ì¡°ì • */
    .seg-btn span.dot { width: 6px; height: 6px; border-radius: 50%; background: #22c55e; }
    .seg-btn#btn-eff span.dot { background: #8b5cf6; }

    #filter-control {
      position: fixed;
      left: 12px;
      bottom: 20px;
      z-index: 20;

      /* ì›í˜• ëª¨ì–‘ ì¡ê¸° */
      width: 40px;
      height: 40px;
      border-radius: 20px;
  
      /* ë””ìì¸ (ìš°ì¸¡ ì»´í¬ë„ŒíŠ¸ì™€ í†µì¼) */
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(4px);
      color: #374151; /* ì•„ì´ì½˜ ìƒ‰ìƒ (ì§„í•œ íšŒìƒ‰) */
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
  
      /* ë‚´ë¶€ ì•„ì´ì½˜ ì •ë ¬ */
      display: flex;
      align-items: center;
      overflow: hidden; /* ë‚´ë¶€ ìŠ¬ë¼ì´ë” ìˆ¨ê¹€ */
      white-space: nowrap;
  
      transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.2s, opacity 0.3s, transform 0.3s;
      cursor: pointer;
    }

    #filter-control.expanded {
      width: 220px; /* ìŠ¬ë¼ì´ë”ê°€ ë“¤ì–´ê°ˆ ê³µê°„ í™•ë³´ */
      background: #fff;
      border-color: #d1d5db;
    }

    #filter-control.hidden-ui {
      opacity: 0;
      pointer-events: none; /* ì•ˆ ë³´ì¼ ë•Œ í´ë¦­ ë°©ì§€ */
      transform: translateX(-20px); /* ì™¼ìª½ìœ¼ë¡œ ì‚´ì§ ë°€ë¦¬ë©´ì„œ ì‚¬ë¼ì§ */
    }

    #filter-icon-wrapper {
      min-width: 40px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    #filter-slider-box {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 16px;
      opacity: 0; /* ê¸°ë³¸ì ìœ¼ë¡œ ìˆ¨ê¹€ */
      white-space: nowrap;
      transition: opacity 0.2s ease-in;
    }

    #filter-control.expanded #filter-slider-box {
      opacity: 1;
    }

    /* ìŠ¬ë¼ì´ë”(Range Input) ìŠ¤íƒ€ì¼ ì»¤ìŠ¤í…€ */
    #time-slider {
      width: 100px;
      accent-color: #2563eb; /* ìŠ¬ë¼ì´ë” ìƒ‰ìƒ */
      cursor: pointer;
    }

    #filter-val-label {
      font-size: 13px;
      font-weight: 700;
      color: #2563eb;
      min-width: 36px;
      text-align: right;
    }

    .dot {
      width: 10px; height: 10px; border-radius: 50%; border: 2px solid #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: transform 0.1s;
    }
    .stop-dot {
      width: 8px; height: 8px; border-radius: 50%; border: 2px solid #fff; background: #1a73e8;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    /* ìŠ¹í•˜ì°¨ ì •ë¥˜ì¥ ë¼ë²¨ ìŠ¤íƒ€ì¼ */
    /* 1. ë§ˆì»¤ì˜ ë³¸ì²´ (= ì ) */
    .station-root-dot {
      width: 10px; 
      height: 10px; 
      border-radius: 50%; 
      background: white;
      border: 3px solid #111827; /* JSì—ì„œ ì¸ë¼ì¸ìœ¼ë¡œ ìƒ‰ìƒ ë®ì–´ì”Œì›€ */
  
      /* ìì‹(ë¼ë²¨)ì˜ ìœ„ì¹˜ ê¸°ì¤€ì ì´ ë¨ */
      position: relative; 
  
      /* í¬ê¸° ê³„ì‚° ë‹¨ìˆœí™” */
      box-sizing: content-box; 
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  
      /* ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë¬´ì‹œ (ì„ íƒì‚¬í•­) */
      pointer-events: none;
    }

    /* 2. ì  ìœ„ì— ë‘¥ë‘¥ ë– ìˆëŠ” ë¼ë²¨ */
    .station-label {
      position: absolute;
  
      /* ì ì˜ ë°”ë¡œ ìœ„ìª½ìœ¼ë¡œ ë°°ì¹˜ */
      bottom: 18px; /* ì  ë†’ì´(16px) + ì•½ê°„ì˜ ì—¬ë°±(2px) */
      left: 50%;
  
      /* ê°€ë¡œ ì¤‘ì•™ ì •ë ¬ë§Œ ìˆ˜í–‰ (ì„¸ë¡œ ê³„ì‚° ë¶ˆí•„ìš”) */
      transform: translateX(-50%);
  
      /* ë””ìì¸ (ê¸°ì¡´ê³¼ ë™ì¼) */
      padding: 4px 8px;
      border-radius: 6px;
      color: white;
      font-size: 11px;
      font-weight: 600;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      white-space: nowrap;
      z-index: 20; /* ì ë³´ë‹¤ ìœ„ì— í‘œì‹œ */
    }
    /* ë§í’ì„  ê¼¬ë¦¬ ë§Œë“¤ê¸° */
    .station-label::after {
      content: ''; position: absolute; bottom: -4px; left: 50%;
      transform: translateX(-50%); border-width: 4px; border-style: solid;
    }


    /* ìŠ¹ì°¨ ìŠ¤íƒ€ì¼ (íŒŒë€ìƒ‰ ê³„ì—´) */
    .station-label.board { background: #2563eb; }
    .station-label.board::after { border-color: #2563eb transparent transparent transparent; }

    /* í•˜ì°¨ ìŠ¤íƒ€ì¼ (ë¶‰ì€ìƒ‰ ê³„ì—´) */
    .station-label.drop { background: #ef4444; }
    .station-label.drop::after { border-color: #ef4444 transparent transparent transparent; }
  </style>
</head>
<body>
  <div id="app">

    <div id="map"></div>

    <div id="sidebar">
      <div id="sidebar-content" style="height: 100%; display: flex; flex-direction: column;"></div>
    </div>

    <div id="floating-controls">
      <div id="legend">
        <div class="lg-title" id="legend-title">ì†Œìš”ì‹œê°„ (ë¶„)</div>
        <div id="legend-rows"></div>
      </div>

      <div id="mode-toggle">
        <button id="btn-time" class="seg-btn active"><span class="dot"></span>ì‹œê°„</button>
        <button id="btn-eff" class="seg-btn"><span class="dot"></span>íš¨ìœ¨</button>
      </div>
    </div>

    <div id="filter-control">
      <div id="filter-icon-wrapper">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="4" y1="21" x2="4" y2="14"></line>
        <line x1="4" y1="10" x2="4" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="12"></line>
        <line x1="12" y1="8" x2="12" y2="3"></line>
        <line x1="20" y1="21" x2="20" y2="16"></line>
        <line x1="20" y1="12" x2="20" y2="3"></line>
        <line x1="1" y1="14" x2="7" y2="14"></line>
        <line x1="9" y1="8" x2="15" y2="8"></line>
        <line x1="17" y1="16" x2="23" y2="16"></line>
      </svg>
    </div>
    <div id="filter-slider-box">
      <span id="filter-val-label">ì „ì²´</span>
      <input type="range" id="time-slider" min="5" max="60" step="5" value="60">
    </div>  
  </div>

  <script>
    // ---------- 1. ê¸°ë³¸ ì„¤ì • ----------
    const DEST = { lat: 37.563729, lng: 126.936898 }; 
    const BACKEND_BASE = "https://oversimply-tibial-elsy.ngrok-free.dev";
    const DATA_URL = "data/data.json";

    const COLORS = ['#22c55e','#84cc16','#eab308','#f97316','#ef4444','#8b5cf6'];
    let MODE = 'time';
    let DATA = null;
    let EFF_BREAKS = null;

    let mapInstance = null;
    let POINTS = [];
    let markers = [];
    let clusterMarkers = [];
    let routePolylines = [];
    let stopMarkers = [];
    let selectedPoint = null; 
    let FILTER_LIMIT = 60; // 60ì´ë©´ 'ì „ì²´'ë¡œ ê°„ì£¼

    const CLUSTER_THRESHOLD = 3000; 
    const CLUSTER_ZOOM_ON   = 15; 
    const MAX_SLIDER_VAL = 60;  

    const ICON_HOME = `
      <div style="
        width: 36px; height: 36px; background: #111827;
        border: 2px solid #fff; border-radius: 50%;
        display: flex; align-items: center; justify-content: center;
        box-shadow: 0 6px 12px rgba(0,0,0,0.3); cursor: pointer;
      ">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="white">
          <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
      </div>
    `;

    // ---------- 2. ìœ í‹¸ë¦¬í‹° ----------
    function setStatus(text) { 
      console.log("Status:", text); 
    }
    function fmt(n, d=0) { return (n == null || n === '' || isNaN(+n)) ? '-' : (+n).toFixed(d); }
    function esc(s) { return String(s ?? '').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])); }

    function colorForTime(t) {
      if (t == null || isNaN(+t)) return '#9e9e9e';
      if (t <= 10) return COLORS[0]; if (t <= 15) return COLORS[1];
      if (t <= 20) return COLORS[2]; if (t <= 25) return COLORS[3];
      if (t <= 30) return COLORS[4]; return COLORS[5];
    }

    function colorForEff(eff) {
      if (eff == null || isNaN(+eff)) return '#9e9e9e';
      if (!EFF_BREAKS || EFF_BREAKS.length !== 4) return COLORS[5];
      const [q1,q2,q3,q4] = EFF_BREAKS;
      if (eff <= q1) return COLORS[0]; if (eff <= q2) return COLORS[1];
      if (eff <= q3) return COLORS[2]; if (eff <= q4) return COLORS[3];
      return COLORS[4];
    }

    function computeEffBreaks(geo) {
      const vals = [];
      for (const f of geo.features || []) {
        const v = Number(f.properties?.efficiency);
        if (!isNaN(v) && isFinite(v)) vals.push(v);
      }
      if (!vals.length) return null;
      vals.sort((a,b)=>a-b);
      const q = p => vals[Math.floor(p*(vals.length-1))];
      return [q(0.2), q(0.4), q(0.6), q(0.8)];
    }

    // ---------- 3. UI ì œì–´ ----------
    function applyMode() {
      updateLegend();
      document.getElementById('btn-time').classList.toggle('active', MODE==='time');
      document.getElementById('btn-eff').classList.toggle('active',  MODE==='eff');
      updateVisibleMarkers();
    }

    function updateLegend() {
      const rows = document.getElementById('legend-rows');
      const title = document.getElementById('legend-title');
      rows.innerHTML = '';
      if (MODE === 'time') {
        title.textContent = 'ì†Œìš”ì‹œê°„ (ë¶„)';
        const labels = ['0-10','10-15','15-20','20-25','25-30','30+'];
        COLORS.forEach((c, i) => {
          rows.innerHTML += `<div class="lg-row"><span class="swatch" style="background:${c}"></span><span>${labels[i]}</span></div>`;
        });
      } else {
        title.textContent = 'íš¨ìœ¨';
        const b = EFF_BREAKS || [];
        const labels = b.length===4 ? ['ë§¤ìš° ì¢‹ìŒ','ì¢‹ìŒ','ë³´í†µ','ë‚˜ì¨','ë§¤ìš° ë‚˜ì¨'] : ['1','2','3','4','5'];
        const cols = [...COLORS].slice(0,5);
        cols.forEach((c, i) => {
          rows.innerHTML += `<div class="lg-row"><span class="swatch" style="background:${c}"></span><span>${labels[i]}</span></div>`;
        });
      }
    }

    function openSidebar(marker) {
      const filterCtrl = document.getElementById('filter-control');
      if (filterCtrl) filterCtrl.classList.add('hidden-ui');

      const p = marker.__props || {};
      const sidebar = document.getElementById('sidebar');
      const content = document.getElementById('sidebar-content');

      // 2. ê°€ê²© í¬ë§·íŒ… ë¡œì§ (5000@50 -> ë³´ì¦ê¸ˆ 5000 / ì›”ì„¸ 50)
      let rentDisplay = esc(p.rent || '-'); // ê¸°ë³¸ê°’
      if (p.rent && p.rent.includes('@')) {
        const parts = p.rent.split('@');
        if (parts.length === 2) {
          // í•„ìš”í•˜ë‹¤ë©´ ë’¤ì— 'ë§Œì›' ë‹¨ìœ„ë¥¼ ë¶™ì—¬ë„ ë©ë‹ˆë‹¤. ì˜ˆ: parts[0] + 'ë§Œì›'
          rentDisplay = `ë³´ì¦ê¸ˆ ${esc(parts[0])} / ì›”ì„¸ ${esc(parts[1])}`;
        }
      }

      // 1. ì´ë™ìˆ˜ë‹¨ ê°’ í™•ì¸ (ê³µë°± ì œê±° ë° ì†Œë¬¸ì)
      const rideMode = (p.ride || '').toString().trim().toLowerCase();

      // 2. ì´ë™ìˆ˜ë‹¨ì— ë”°ë¼ í‘œì‹œí•  HTML ê²°ì •
      let routeDetailHtml = '';

      if (rideMode === 'walk' || rideMode === 'walk_only') {
        // [ìˆ˜ì • í¬ì¸íŠ¸] ë„ë³´ì¼ ë•ŒëŠ” í™”ì‚´í‘œ ì—†ì´ ê¹”ë”í•˜ê²Œ 'ë„ë³´ Oë¶„'ë§Œ í‘œì‹œ
        routeDetailHtml = `<span>ğŸš¶ ë„ë³´ ${fmt(p.exp_time)}ë¶„</span>`;
      } else {
        // ëŒ€ì¤‘êµí†µì¼ ë•ŒëŠ” ê¸°ì¡´ì²˜ëŸ¼ ìƒì„¸ ë‹¨ê³„ í‘œì‹œ (ê±·ê¸° -> ë²„ìŠ¤ -> ê±·ê¸°)
        routeDetailHtml = `
            <span>ğŸš¶ ${fmt(p.w1)}ë¶„</span>
            <span style="color:#9ca3af">â†’</span>
            <span>ğŸšŒ ${fmt(p.t1)}ë¶„</span>
            <span style="color:#9ca3af">â†’</span>
            <span>ğŸš¶ ${fmt(p.w2)}ë¶„</span>
        `;
      }

      content.innerHTML = `
        <div class="sb-header">
          <div class="sb-title">${esc(p.name || 'ê±´ë¬¼ ì •ë³´')}</div>
          <button class="sb-close" onclick="closeSidebar()">Ã—</button>
        </div>
        <div class="sb-body">
          <div class="sb-row"><span style="background:#f3f4f6; padding:2px 6px; border-radius:4px; font-size:12px;">${esc(p.usage || 'ìš©ë„ë¯¸ìƒ')}</span></div>
          <div class="sb-row"><b>ì£¼ì†Œ:</b> ${esc(p.address || '-')}</div>
          <div class="sb-row"><b>ê°€ê²©:</b> ${rentDisplay} <span style="color:#9ca3af">|</span> <b>ë©´ì :</b> ${fmt(p.area,1)}ã¡</div>
          <hr style="border:0; border-top:1px solid #eee; margin:16px 0;">
          <div class="sb-row"><b>ì´ë™ìˆ˜ë‹¨:</b> ${esc(p.ride || 'ì •ë³´ ì—†ìŒ')}</div>
          
          <div class="sb-row" style="display:flex; align-items:center; gap:4px; font-size:13px;">
            ${routeDetailHtml}
          </div>

          <div class="sb-row" style="margin-top:12px; font-size:16px; font-weight:600; color:#2563eb;">
             ë°°ì°¨ê°„ê²©ì„ ê³ ë ¤í•œ ê¸°ëŒ€ì†Œìš”ì‹œê°„: ${fmt(p.exp_time)}ë¶„
          </div>
           <div class="sb-row" style="color:#6b7280; font-size:12px;">
             íš¨ìœ¨ì§€ìˆ˜: ${fmt(p.efficiency, 3)} (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
        </div>
      `;
      sidebar.classList.add('active');
      window.currentMarker = marker;
    }

    function closeSidebar() {
      document.getElementById('sidebar').classList.remove('active');

      const filterCtrl = document.getElementById('filter-control');
      if (filterCtrl) filterCtrl.classList.remove('hidden-ui');

      clearRouteOverlays();
      if (selectedPoint) {
        selectedPoint = null;
        updateVisibleMarkers();
      }
    }
    
    function refreshRoute() {
      if (window.currentMarker) requestRoute(window.currentMarker);
    }

    // ìŠ¤ë§ˆíŠ¸ ë·°í¬íŠ¸ ì •ë ¬ (ì• ë‹ˆë©”ì´ì…˜ + ì •í™•ë„ ëª¨ë‘ ì¡ëŠ” íŠ¸ë¦­)
    function fitMapToBounds(coords) {
      if (!mapInstance || !coords || coords.length === 0) return;
      
      const bounds = new naver.maps.LatLngBounds();
      coords.forEach(p => bounds.extend(p));

      // í™”ë©´ í¬ê¸° í™•ì¸
      const winWidth = window.innerWidth;
      const winHeight = window.innerHeight;
      const isMobile = winWidth < 768;
      
      // ì—¬ë°± ì„¤ì • (ì‚¬ì´ë“œë°”ì— ê°€ë ¤ì§€ì§€ ì•Šê²Œ)
      let topPad = 50;
      let rightPad = 50;
      let bottomPad = 50;
      let leftPad = 50;

      if (isMobile) {
        // ëª¨ë°”ì¼: í•˜ë‹¨ ì‹œíŠ¸ ë†’ì´ ê³ ë ¤
        const sheetHeight = winHeight * 0.45;
        bottomPad = Math.min(sheetHeight + 40, winHeight * 0.6); 
      } else {
        // ë°ìŠ¤í¬íƒ‘: ì‚¬ì´ë“œë°” í™•ì¸
        const sidebar = document.getElementById('sidebar');
        const isOpen = sidebar && sidebar.classList.contains('active');
        
        if (isOpen) {
          // ì‚¬ì´ë“œë°” ë„ˆë¹„(320) + ì—¬ìœ (50)
          const targetPad = 320 + 50;
          leftPad = Math.min(targetPad, winWidth * 0.45);
        }
      }

      // [í•µì‹¬ íŠ¸ë¦­]
      // 1. í˜„ì¬ ìœ„ì¹˜ ê¸°ì–µ
      const currentCenter = mapInstance.getCenter();
      const currentZoom = mapInstance.getZoom();

      // 2. fitBoundsë¡œ ëª©í‘œ ìœ„ì¹˜(ì¤Œ, ì¤‘ì‹¬)ë¥¼ ê°•ì œë¡œ ê³„ì‚° (í™”ë©´ì—” ì•ˆ ê·¸ë ¤ì§)
      mapInstance.fitBounds(bounds, {
        top: topPad, right: rightPad, bottom: bottomPad, left: leftPad
      });
      
      // 3. ê³„ì‚°ëœ ëª©í‘œ ì§€ì  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
      const targetCenter = mapInstance.getCenter();
      const targetZoom = mapInstance.getZoom();

      // 4. ë‹¤ì‹œ ì›ë˜ ìœ„ì¹˜ë¡œ ìˆœì‹ê°„ì— ë³µê·€ (ë¸Œë¼ìš°ì €ê°€ ê·¸ë¦¬ê¸° ì „ì— ì‹¤í–‰ë˜ë¯€ë¡œ ê¹œë¹¡ì„ ì—†ìŒ)
      mapInstance.setCenter(currentCenter);
      mapInstance.setZoom(currentZoom);

      // 5. ëª©í‘œ ì§€ì ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ì• ë‹ˆë©”ì´ì…˜ (morph)
      // morphëŠ” ì¤Œê³¼ ì¤‘ì‹¬ ì´ë™ì„ ë™ì‹œì— ë¶€ë“œëŸ½ê²Œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
      mapInstance.morph(targetCenter, targetZoom);
    }

    function updateVisibleMarkers() {
      if (!mapInstance || !POINTS.length) return;
      const bounds = mapInstance.getBounds();
      const zoom = mapInstance.getZoom();
      if (!bounds) return;

      const viewportPoints = [];
      let activePt = null;

      // ìŠ¬ë¼ì´ë” í•„í„° í™œì„±í™” ì—¬ë¶€
      const isFiltering = FILTER_LIMIT < MAX_SLIDER_VAL;

      for (const pt of POINTS) {
        const p = pt.props || {};
        const isSelected = selectedPoint && (pt.lat === selectedPoint.lat && pt.lng === selectedPoint.lng);
        
        if (isSelected) activePt = pt;

        // ì„ íƒëœ ë§ˆì»¤ê°€ ì•„ë‹ ë•Œë§Œ í•„í„°ë§ ê²€ì‚¬
        if (!isSelected) {
            
            // 1. ê¸°ì¡´ ìŠ¬ë¼ì´ë” í•„í„° (ì‹œê°„)
            if (isFiltering && p.exp_time > FILTER_LIMIT) continue;

            // 2. [ì¶”ê°€ë¨] íš¨ìœ¨ ëª¨ë“œì¼ ë•Œì˜ íŠ¹ë³„ ì œí•œ ì¡°ê±´
            if (MODE === 'eff') {
                // ì¡°ê±´ A: ì‹œê°„ì´ 30ë¶„ì„ ì´ˆê³¼í•˜ë©´ ì œì™¸
                if (p.exp_time > 30) continue;

                // ì¡°ê±´ B: ì›”ì„¸ê°€ 65ë§Œì›ì„ ì´ˆê³¼í•˜ë©´ ì œì™¸
                // ë°ì´í„° í˜•ì‹ì´ "5000@50"ì´ë¯€ë¡œ @ ë’¤ì˜ ìˆ«ìë¥¼ ì¶”ì¶œ
                let monthlyRent = 0;
                if (p.rent && p.rent.toString().includes('@')) {
                    const parts = p.rent.toString().split('@');
                    if (parts.length > 1) {
                        monthlyRent = Number(parts[1]); // '@' ë’¤ì˜ ìˆ«ì(ì›”ì„¸) ë³€í™˜
                    }
                }
                
                // ì›”ì„¸ê°€ 65ë§Œì›ì„ ë„˜ìœ¼ë©´ ê±´ë„ˆëœ€ (ì „ì„¸ ë“± @ê°€ ì—†ëŠ” ê²½ìš°ëŠ” 0ì›ìœ¼ë¡œ ì²˜ë¦¬ë˜ì–´ í†µê³¼ë¨)
                if (monthlyRent > 65) continue;
            }
        }

        // 3. í˜„ì¬ í™”ë©´(ì§€ë„ ì˜ì—­) ì•ˆì— ìˆëŠ” ì ë§Œ ìˆ˜ì§‘
        if (bounds.hasLatLng(new naver.maps.LatLng(pt.lat, pt.lng))) {
          viewportPoints.push(pt);
        }
      }

      // ê¸°ì¡´ ë§ˆì»¤ë“¤ ì‚­ì œ
      markers.forEach(m => m.setMap(null)); markers = [];
      clusterMarkers.forEach(c => c.setMap(null)); clusterMarkers = [];

      // í´ëŸ¬ìŠ¤í„°ë§ ëŒ€ìƒ ì„ ë³„ (ì„ íƒëœ ë§ˆì»¤ëŠ” í´ëŸ¬ìŠ¤í„°ë§ì—ì„œ ì œì™¸)
      const pointsToCluster = viewportPoints.filter(pt => {
        if (!selectedPoint) return true;
        return pt.lat !== selectedPoint.lat || pt.lng !== selectedPoint.lng;
      });

      const useCluster = !isFiltering && (pointsToCluster.length > CLUSTER_THRESHOLD || zoom <= CLUSTER_ZOOM_ON);

      // ì„ íƒëœ ì§‘(activePt)ì€ í•­ìƒ ë³„ë„ ë§ˆì»¤ë¡œ í‘œì‹œ
      if (activePt) {
        const marker = new naver.maps.Marker({
          map: mapInstance,
          position: new naver.maps.LatLng(activePt.lat, activePt.lng),
          zIndex: 9999,
          icon: { content: ICON_HOME, anchor: new naver.maps.Point(18,18) }
        });
        marker.__props = activePt.props;
        marker.__coord = { lat: activePt.lat, lng: activePt.lng };
        
        naver.maps.Event.addListener(marker, 'click', () => {
           openSidebar(marker);
           requestRoute(marker);
        });
        markers.push(marker);
      }

      // ë‚˜ë¨¸ì§€ ì ë“¤ ê·¸ë¦¬ê¸° (í´ëŸ¬ìŠ¤í„°ë§ or ê°œë³„ ì )
      if (useCluster) {
        const proj = mapInstance.getProjection();
        const clusterMap = new Map();
        const gridSize = 80;

        for (const pt of pointsToCluster) {
          const latlng = new naver.maps.LatLng(pt.lat, pt.lng);
          const pixel = proj.fromCoordToOffset(latlng);
          const k = `${Math.floor(pixel.x/gridSize)}_${Math.floor(pixel.y/gridSize)}`;
          if (!clusterMap.has(k)) clusterMap.set(k, { pts:[], sumLat:0, sumLng:0 });
          const c = clusterMap.get(k);
          c.pts.push(pt); c.sumLat+=pt.lat; c.sumLng+=pt.lng;
        }

        clusterMap.forEach(c => {
          const count = c.pts.length;
          const center = new naver.maps.LatLng(c.sumLat/count, c.sumLng/count);
          if (count === 1) {
            createDotMarker(c.pts[0]);
          } else {
            const cm = new naver.maps.Marker({
              map: mapInstance,
              position: center,
              icon: {
                content: `<div style="width:32px;height:32px;background:#1f2937;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:12px;box-shadow:0 2px 5px rgba(0,0,0,0.3);">${count}</div>`,
                anchor: new naver.maps.Point(16,16)
              }
            });
            naver.maps.Event.addListener(cm, 'click', () => {
              const nextZoom = Math.min(mapInstance.getZoom() + 2, 17);
              mapInstance.morph(center, nextZoom); // ì—¬ê¸°ë„ ë¶€ë“œëŸ½ê²Œ morph ì‚¬ìš©
            });
            clusterMarkers.push(cm);
          }
        });
      } else {
        pointsToCluster.forEach(pt => createDotMarker(pt));
      }
      const statusText = isFiltering ? `í•„í„°: ${FILTER_LIMIT}ë¶„ ì´ë‚´ (${viewportPoints.length}ê°œ)` : `ì´ ${POINTS.length.toLocaleString()}ê°œ / í™”ë©´ ${viewportPoints.length}ê°œ`;
      setStatus(statusText); 
    }

    function createDotMarker(pt) {
      const props = pt.props || {};
      const color = (MODE === 'time') ? colorForTime(props.exp_time) : colorForEff(props.efficiency);
      
      const m = new naver.maps.Marker({
        map: mapInstance,
        position: new naver.maps.LatLng(pt.lat, pt.lng),
        icon: {
          content: `<div class="dot" style="background:${color};"></div>`,
          anchor: new naver.maps.Point(5,5)
        }
      });
      m.__props = props;
      m.__coord = { lat: pt.lat, lng: pt.lng };

      naver.maps.Event.addListener(m, 'click', () => {
        selectedPoint = { lat: pt.lat, lng: pt.lng };
        updateVisibleMarkers(); 
        openSidebar(m);
        requestRoute(m);
      });
      markers.push(m);
    }

    // ---------- 5. ê²½ë¡œ ë¡œì§ (â˜… ì›ë³¸ìœ¼ë¡œ ë³µì›ëœ ë¶€ë¶„) ----------
    function clearRouteOverlays() {
      routePolylines.forEach(p => p.setMap(null)); routePolylines = [];
      stopMarkers.forEach(m => m.setMap(null)); stopMarkers = [];
    }

    // 1. walk-only (ì ì„ )
    function drawWalkOnlyRoute(originCoord) {
      if (!mapInstance) return;
      clearRouteOverlays();

      const destLatLng = new naver.maps.LatLng(DEST.lat, DEST.lng);
      const originLatLng = new naver.maps.LatLng(originCoord.lat, originCoord.lng);

      const poly = new naver.maps.Polyline({
        map: mapInstance,
        path: [originLatLng, destLatLng],
        strokeColor: '#111827',
        strokeOpacity: 0.8,
        strokeStyle: 'shortdash',
        strokeWeight: 2
      });
      routePolylines.push(poly);
      
      fitMapToBounds([originLatLng, destLatLng]);
    }

    // 2. API í˜¸ì¶œ (ì›ë³¸ ë°©ì‹ìœ¼ë¡œ ë³µì›)
    async function requestRoute(marker) {
      const p = marker.__props || {};
      const coord = marker.__coord || {}; 
      
      // ì›ë³¸ ë¡œì§: 'walk' ë˜ëŠ” 'walk_only'ì™€ ì •í™•íˆ ì¼ì¹˜í•  ë•Œë§Œ ì ì„ 
      if ((p.ride || '').toLowerCase() === 'walk' || (p.ride || '').toLowerCase() === 'walk_only') {
        drawWalkOnlyRoute(coord);
        return;
      }

      setStatus("ê²½ë¡œ ê³„ì‚° ì¤‘â€¦");

      const params = new URLSearchParams({
        from_lat: String(coord.lat),
        from_lng: String(coord.lng),
        ride: p.ride || '',
        board: p.board || '',
        drop: p.drop || ''
      });

      try {
        // â˜…â˜…â˜… ì—¬ê¸° fetch ë¶€ë¶„ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤ â˜…â˜…â˜…
        const resp = await fetch(`${BACKEND_BASE}/api/route?${params.toString()}`, {
            method: 'GET',
            headers: {
                "ngrok-skip-browser-warning": "69420", // ì´ í—¤ë”ê°€ ìˆì–´ì•¼ ngrok ê²½ê³ ì°½ì„ ë¬´ì‹œí•˜ê³  í†µê³¼í•©ë‹ˆë‹¤
                "Content-Type": "application/json"
            }
        });

        if (!resp.ok) {
          const msg = await resp.text();
          console.error("route error", msg);
          setStatus("ê²½ë¡œ ê³„ì‚° ì‹¤íŒ¨ (ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜)");
          return;
        }
        const data = await resp.json();
        // ì›ë³¸ ë¡œì§: p(props)ë¥¼ ì„¸ ë²ˆì§¸ ì¸ìë¡œ ì „ë‹¬
        drawRouteFromLane(data, coord, p); 
      } catch (e) {
        console.error(e);
        setStatus("ê²½ë¡œ ê³„ì‚° ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
        drawWalkOnlyRoute(coord); // ì˜¤ë¥˜ ì‹œ fallback
      }
    }

    // 3. ê²½ë¡œ ê·¸ë¦¬ê¸° (ì›ë³¸ ë°©ì‹ìœ¼ë¡œ ë³µì›)
    function drawRouteFromLane(data, originCoord, props) {
      if (!mapInstance) return;
      clearRouteOverlays();

      if (!data || !data.result || !Array.isArray(data.result.lane)) {
        drawWalkOnlyRoute(originCoord);
        return;
      }

      const result = data.result;
      const polyPaths = [];
      const stationLatLngs = [];
      const stationNames   = [];
      const allStations = [];
      
      // ë·°í¬íŠ¸ ì¡°ì ˆìš© ì „ì²´ ì¢Œí‘œ ìˆ˜ì§‘
      let allPointsForBounds = [];
      const originLatLng = new naver.maps.LatLng(originCoord.lat, originCoord.lng);
      const destLatLng   = new naver.maps.LatLng(DEST.lat, DEST.lng);
      allPointsForBounds.push(originLatLng, destLatLng);

      let firstRoutePoint = null;
      let lastRoutePoint  = null;

      for (const lane of result.lane) {
        const sections = lane.section || [];
        for (const section of sections) {
          const graphPos = section.graphPos || [];
          const path = [];

          for (const gp of graphPos) {
            const x = Number(gp.x);
            const y = Number(gp.y);
            if (isNaN(x) || isNaN(y)) continue;
            const latlng = new naver.maps.LatLng(y, x);
            path.push(latlng);
            allPointsForBounds.push(latlng); // ë·°í¬íŠ¸ìš©

            if (!firstRoutePoint) firstRoutePoint = latlng;
            lastRoutePoint = latlng;
          }

          if (path.length >= 2) {
            polyPaths.push(path);
          }

          const stations = section.station || [];
          for (const st of stations) {
            const sx = Number(st.x);
            const sy = Number(st.y);
            if (isNaN(sx) || isNaN(sy)) continue;
            const latlng = new naver.maps.LatLng(sy, sx);
            stationLatLngs.push(latlng);
            stationNames.push(st.stationName || '');
            allStations.push({ latlng, name: st.stationName || '' });
          }
        }
      }

      for (const path of polyPaths) {
        const pl = new naver.maps.Polyline({
          map: mapInstance,
          path,
          strokeColor: '#2563eb',
          strokeWeight: 3,
          strokeOpacity: 0.9
        });
        routePolylines.push(pl);
      }

      for (let i = 0; i < stationLatLngs.length; i++) {
        const marker = new naver.maps.Marker({
          map: mapInstance,
          position: stationLatLngs[i],
          icon: {
            content: '<div class="stop-dot"></div>',
            anchor: new naver.maps.Point(4,4)
          },
          title: stationNames[i]
        });
        stopMarkers.push(marker);
      }

      // --- propsë¥¼ í™œìš©í•œ ì •ë¥˜ì¥ ë§¤ì¹­ ë¡œì§ (ë³µì›ë¨) ---
      let boardLatLng = firstRoutePoint; 
      let dropLatLng  = lastRoutePoint;

      // ë§ˆì»¤ì— í‘œì‹œí•  ì‹¤ì œ ì´ë¦„ ë³€ìˆ˜
      let finalBoardName = (props?.board || '').trim();
      let finalDropName  = (props?.drop || '').trim();

      if (allStations.length) {
        if (finalBoardName) {
          const foundBoard = allStations.find(s => (s.name || '').includes(finalBoardName));
          if (foundBoard) {finalBoardName = foundBoard.name;}
        }
        if (finalDropName) {
          const rev = [...allStations].reverse();
          const foundDrop = rev.find(s => (s.name || '').includes(finalDropName));
          if (foundDrop) {finalDropName = foundDrop.name;}
        }
      }

      if (boardLatLng) {
        const walk1 = new naver.maps.Polyline({
          map: mapInstance,
          path: [originLatLng, boardLatLng],
          strokeColor: '#111827',
          strokeOpacity: 0.8,
          strokeStyle: [4, 6],
          strokeWeight: 2
        });
        routePolylines.push(walk1);

        const boardMarker = new naver.maps.Marker({
          map: mapInstance,
          position: boardLatLng,
          zIndex: 1000,
          icon: {
            content: `
                <div class="station-root-dot" style="border-color: #2563eb;">
                    <div class="station-label board">${finalBoardName} ìŠ¹ì°¨</div>
                </div>
            `,
            anchor: new naver.maps.Point(8, 8)
          },
        });
        stopMarkers.push(boardMarker);
      }

      if (dropLatLng) {
        const walk2 = new naver.maps.Polyline({
          map: mapInstance,
          path: [dropLatLng, destLatLng],
          strokeColor: '#111827',
          strokeOpacity: 0.8,
          strokeStyle: [4, 6],
          strokeWeight: 2
        });
        routePolylines.push(walk2);

        const dropMarker = new naver.maps.Marker({
          map: mapInstance,
          position: dropLatLng,
          zIndex: 1000,
          icon: {
            content: `
                <div class="station-root-dot" style="border-color: #ef4444;">
                    <div class="station-label drop">${finalDropName} í•˜ì°¨</div>
                </div>
            `,
            anchor: new naver.maps.Point(8, 8)
          },
        });
        stopMarkers.push(dropMarker);
      }
      
      // ìŠ¤ë§ˆíŠ¸ ë·°í¬íŠ¸ ì ìš© (ì´ê±´ í¸ì˜ê¸°ëŠ¥ì´ë¼ ë‚¨ê²¨ë‘ )
      fitMapToBounds(allPointsForBounds);
      setStatus("ê²½ë¡œ í‘œì‹œ ì™„ë£Œ");
    }

    // ---------- 6. ë¡œë“œ ë° ì´ˆê¸°í™” ----------
    async function loadData() {
      try {
        const res = await fetch(DATA_URL);
        const json = await res.json();
        DATA = json;
        EFF_BREAKS = computeEffBreaks(DATA);
        POINTS = [];
        (DATA.features||[]).forEach(f => {
          if(f.geometry?.type==='Point') {
            const [lng, lat] = f.geometry.coordinates;
            const props = {...f.properties, lat, lng};
            if(props.exp_time && props.price_per_py_m && !props.efficiency) {
              props.efficiency = props.exp_time / props.price_per_py_m;
            }
            POINTS.push({lat, lng, props});
          }
        });
        applyMode();
      } catch(e) {
        console.error(e);
        setStatus("ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨");
      }
    }

    function initMap() {
      const map = new naver.maps.Map('map', {
        center: new naver.maps.LatLng(DEST.lat, DEST.lng),
        zoom: 14,
        scaleControl: false, logoControl: false, mapDataControl: false,
      });
      mapInstance = map;

      new naver.maps.Marker({
        map, position: new naver.maps.LatLng(DEST.lat, DEST.lng),
        title: 'ë„ì„œê´€',
        icon: { content: '<div style="font-size:20px;">ğŸ«</div>', anchor: new naver.maps.Point(10,10) }
      });

      naver.maps.Event.addListener(map, 'idle', updateVisibleMarkers);
      naver.maps.Event.addListener(map, 'click', () => {
        closeSidebar(); 
      });

      document.getElementById('btn-time').addEventListener('click', ()=>{ MODE='time'; applyMode(); });
      document.getElementById('btn-eff').addEventListener('click', ()=>{ MODE='eff'; applyMode(); });

      const filterCtrl = document.getElementById('filter-control');
      const slider = document.getElementById('time-slider');
      const label = document.getElementById('filter-val-label');

      if (filterCtrl && slider) {
        // 1. ë²„íŠ¼ í´ë¦­ ì‹œ í™•ì¥/ì¶•ì†Œ í† ê¸€
        filterCtrl.addEventListener('click', (e) => {
           // ìŠ¬ë¼ì´ë”(input) ìì²´ë¥¼ í´ë¦­í•˜ê±°ë‚˜ ë“œë˜ê·¸í•  ë•ŒëŠ” ë‹«íˆì§€ ì•Šë„ë¡ ë°©ì§€
           if (e.target === slider) return;
           
           // 'expanded' í´ë˜ìŠ¤ë¥¼ ê»ë‹¤ ì¼°ë‹¤ í•¨ -> CSSê°€ ë°˜ì‘í•˜ì—¬ ëŠ˜ì–´ë‚¬ë‹¤ ì¤„ì–´ë“¦
           filterCtrl.classList.toggle('expanded');
        });

        // 2. ìŠ¬ë¼ì´ë” ê°’ ë³€ê²½ ì‹œ ë™ì‘
        slider.addEventListener('input', (e) => {
           const val = Number(e.target.value);
           FILTER_LIMIT = val; // ì „ì—­ ë³€ìˆ˜ ì—…ë°ì´íŠ¸

           // ë¼ë²¨ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
           if (val === 60) {
              label.textContent = 'ì „ì²´';
           } else {
              label.textContent = `${val}ë¶„`;
           }
           
           // ì§€ë„ ë§ˆì»¤ ìƒˆë¡œê³ ì¹¨ (í•„í„°ë§ ì ìš©)
           updateVisibleMarkers();
        });
      }

      loadData();
    }
  </script>
</body>
</html>
