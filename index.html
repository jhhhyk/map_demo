<script>
    // ---------- 1. ê¸°ë³¸ ì„¤ì • ----------
    const DEST = { lat: 37.563729, lng: 126.936898 }; 
    
    // [ì¤‘ìš”] ì—¬ê¸°ì— ODsay 'WEBìš©' API Keyë¥¼ ë„£ìœ¼ì„¸ìš” (Render í‚¤ ì•„ë‹˜!)
    const ODSAY_KEY = "oU72P97mHlqhG+UPuxw2Lw"; 

    const DATA_URL = "data/data.json";

    const COLORS = ['#22c55e','#84cc16','#eab308','#f97316','#ef4444','#8b5cf6'];
    let MODE = 'time';
    let DATA = null;
    let EFF_BREAKS = null;

    let mapInstance = null;
    let POINTS = [];
    let markers = [];
    let clusterMarkers = [];
    let routePolylines = [];
    let stopMarkers = [];
    let selectedPoint = null; 
    let FILTER_LIMIT = 60;

    const CLUSTER_THRESHOLD = 3000; 
    const CLUSTER_ZOOM_ON   = 15; 
    const MAX_SLIDER_VAL = 60;  

    const ICON_HOME = `
      <div style="
        width: 36px; height: 36px; background: #111827;
        border: 2px solid #fff; border-radius: 50%;
        display: flex; align-items: center; justify-content: center;
        box-shadow: 0 6px 12px rgba(0,0,0,0.3); cursor: pointer;
      ">
        <svg viewBox="0 0 24 24" width="20" height="20" fill="white">
          <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
      </div>
    `;

    // ---------- 2. ìœ í‹¸ë¦¬í‹° ----------
    function setStatus(text) { 
      console.log("Status:", text); 
    }
    function fmt(n, d=0) { return (n == null || n === '' || isNaN(+n)) ? '-' : (+n).toFixed(d); }
    function esc(s) { return String(s ?? '').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])); }
    
    function colorForTime(t) {
      if (t == null || isNaN(+t)) return '#9e9e9e';
      if (t <= 10) return COLORS[0]; if (t <= 15) return COLORS[1];
      if (t <= 20) return COLORS[2]; if (t <= 25) return COLORS[3];
      if (t <= 30) return COLORS[4]; return COLORS[5];
    }

    function colorForEff(eff) {
      if (eff == null || isNaN(+eff)) return '#9e9e9e';
      if (!EFF_BREAKS || EFF_BREAKS.length !== 4) return COLORS[5];
      const [q1,q2,q3,q4] = EFF_BREAKS;
      if (eff <= q1) return COLORS[0]; if (eff <= q2) return COLORS[1];
      if (eff <= q3) return COLORS[2]; if (eff <= q4) return COLORS[3];
      return COLORS[4];
    }

    function computeEffBreaks(geo) {
      const vals = [];
      for (const f of geo.features || []) {
        const v = Number(f.properties?.efficiency);
        if (!isNaN(v) && isFinite(v)) vals.push(v);
      }
      if (!vals.length) return null;
      vals.sort((a,b)=>a-b);
      const q = p => vals[Math.floor(p*(vals.length-1))];
      return [q(0.2), q(0.4), q(0.6), q(0.8)];
    }

    // ---------- 3. UI ì œì–´ (ê¸°ì¡´ê³¼ ë™ì¼) ----------
    function applyMode() {
      updateLegend();
      document.getElementById('btn-time').classList.toggle('active', MODE==='time');
      document.getElementById('btn-eff').classList.toggle('active',  MODE==='eff');
      updateVisibleMarkers();
    }

    function updateLegend() {
      const rows = document.getElementById('legend-rows');
      const title = document.getElementById('legend-title');
      rows.innerHTML = '';
      if (MODE === 'time') {
        title.textContent = 'ì†Œìš”ì‹œê°„ (ë¶„)';
        const labels = ['0-10','10-15','15-20','20-25','25-30','30+'];
        COLORS.forEach((c, i) => {
          rows.innerHTML += `<div class="lg-row"><span class="swatch" style="background:${c}"></span><span>${labels[i]}</span></div>`;
        });
      } else {
        title.textContent = 'íš¨ìœ¨';
        const b = EFF_BREAKS || [];
        const labels = b.length===4 ? ['ë§¤ìš° ì¢‹ìŒ','ì¢‹ìŒ','ë³´í†µ','ë‚˜ì¨','ë§¤ìš° ë‚˜ì¨'] : ['1','2','3','4','5'];
        const cols = [...COLORS].slice(0,5);
        cols.forEach((c, i) => {
          rows.innerHTML += `<div class="lg-row"><span class="swatch" style="background:${c}"></span><span>${labels[i]}</span></div>`;
        });
      }
    }

    function openSidebar(marker) {
      const filterCtrl = document.getElementById('filter-control');
      if (filterCtrl) filterCtrl.classList.add('hidden-ui');

      const p = marker.__props || {};
      const sidebar = document.getElementById('sidebar');
      const content = document.getElementById('sidebar-content');

      let rentDisplay = esc(p.rent || '-');
      if (p.rent && p.rent.includes('@')) {
        const parts = p.rent.split('@');
        if (parts.length === 2) {
          rentDisplay = `ë³´ì¦ê¸ˆ ${esc(parts[0])} / ì›”ì„¸ ${esc(parts[1])}`;
        }
      }

      const rideMode = (p.ride || '').toString().trim().toLowerCase();
      let routeDetailHtml = '';

      if (rideMode === 'walk' || rideMode === 'walk_only') {
        routeDetailHtml = `<span>ğŸš¶ ë„ë³´ ${fmt(p.exp_time)}ë¶„</span>`;
      } else {
        routeDetailHtml = `
            <span>ğŸš¶ ${fmt(p.w1)}ë¶„</span>
            <span style="color:#9ca3af">â†’</span>
            <span>ğŸšŒ ${fmt(p.t1)}ë¶„</span>
            <span style="color:#9ca3af">â†’</span>
            <span>ğŸš¶ ${fmt(p.w2)}ë¶„</span>
        `;
      }

      content.innerHTML = `
        <div class="sb-header">
          <div class="sb-title">${esc(p.name || 'ê±´ë¬¼ ì •ë³´')}</div>
          <button class="sb-close" onclick="closeSidebar()">Ã—</button>
        </div>
        <div class="sb-body">
          <div class="sb-row"><span style="background:#f3f4f6; padding:2px 6px; border-radius:4px; font-size:12px;">${esc(p.usage || 'ìš©ë„ë¯¸ìƒ')}</span></div>
          <div class="sb-row"><b>ì£¼ì†Œ:</b> ${esc(p.address || '-')}</div>
          <div class="sb-row"><b>ê°€ê²©:</b> ${rentDisplay} <span style="color:#9ca3af">|</span> <b>ë©´ì :</b> ${fmt(p.area,1)}ã¡</div>
          <hr style="border:0; border-top:1px solid #eee; margin:16px 0;">
          <div class="sb-row"><b>ì´ë™ìˆ˜ë‹¨:</b> ${esc(p.ride || 'ì •ë³´ ì—†ìŒ')}</div>
          
          <div class="sb-row" style="display:flex; align-items:center; gap:4px; font-size:13px;">
            ${routeDetailHtml}
          </div>

          <div class="sb-row" style="margin-top:12px; font-size:16px; font-weight:600; color:#2563eb;">
             ë°°ì°¨ê°„ê²©ì„ ê³ ë ¤í•œ ê¸°ëŒ€ì†Œìš”ì‹œê°„: ${fmt(p.exp_time)}ë¶„
          </div>
            <div class="sb-row" style="color:#6b7280; font-size:12px;">
              íš¨ìœ¨ì§€ìˆ˜: ${fmt(p.efficiency, 3)} (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
        </div>
      `;
      sidebar.classList.add('active');
      window.currentMarker = marker;
    }

    function closeSidebar() {
      document.getElementById('sidebar').classList.remove('active');
      const filterCtrl = document.getElementById('filter-control');
      if (filterCtrl) filterCtrl.classList.remove('hidden-ui');
      clearRouteOverlays();
      if (selectedPoint) {
        selectedPoint = null;
        updateVisibleMarkers();
      }
    }
    
    function refreshRoute() {
      if (window.currentMarker) requestRoute(window.currentMarker);
    }

    // ìŠ¤ë§ˆíŠ¸ ë·°í¬íŠ¸ ì •ë ¬
    function fitMapToBounds(coords) {
      if (!mapInstance || !coords || coords.length === 0) return;
      
      const bounds = new naver.maps.LatLngBounds();
      coords.forEach(p => bounds.extend(p));

      const winWidth = window.innerWidth;
      const winHeight = window.innerHeight;
      const isMobile = winWidth < 768;
      
      let topPad = 50;
      let rightPad = 50;
      let bottomPad = 50;
      let leftPad = 50;

      if (isMobile) {
        const sheetHeight = winHeight * 0.45;
        bottomPad = Math.min(sheetHeight + 40, winHeight * 0.6); 
      } else {
        const sidebar = document.getElementById('sidebar');
        const isOpen = sidebar && sidebar.classList.contains('active');
        if (isOpen) {
          const targetPad = 320 + 50;
          leftPad = Math.min(targetPad, winWidth * 0.45);
        }
      }

      const currentCenter = mapInstance.getCenter();
      const currentZoom = mapInstance.getZoom();

      mapInstance.fitBounds(bounds, {
        top: topPad, right: rightPad, bottom: bottomPad, left: leftPad
      });
      
      const targetCenter = mapInstance.getCenter();
      const targetZoom = mapInstance.getZoom();

      mapInstance.setCenter(currentCenter);
      mapInstance.setZoom(currentZoom);
      mapInstance.morph(targetCenter, targetZoom);
    }

    function updateVisibleMarkers() {
      if (!mapInstance || !POINTS.length) return;
      const bounds = mapInstance.getBounds();
      const zoom = mapInstance.getZoom();
      if (!bounds) return;

      const viewportPoints = [];
      let activePt = null;
      const isFiltering = FILTER_LIMIT < MAX_SLIDER_VAL;

      for (const pt of POINTS) {
        const p = pt.props || {};
        const isSelected = selectedPoint && (pt.lat === selectedPoint.lat && pt.lng === selectedPoint.lng);
        if (isSelected) activePt = pt;

        if (!isSelected) {
            if (isFiltering && p.exp_time > FILTER_LIMIT) continue;
            if (MODE === 'eff') {
                if (p.exp_time > 30) continue;
                let monthlyRent = 0;
                if (p.rent && p.rent.toString().includes('@')) {
                    const parts = p.rent.toString().split('@');
                    if (parts.length > 1) {
                        monthlyRent = Number(parts[1]);
                    }
                }
                if (monthlyRent > 65) continue;
            }
        }
        if (bounds.hasLatLng(new naver.maps.LatLng(pt.lat, pt.lng))) {
          viewportPoints.push(pt);
        }
      }

      markers.forEach(m => m.setMap(null)); markers = [];
      clusterMarkers.forEach(c => c.setMap(null)); clusterMarkers = [];

      const pointsToCluster = viewportPoints.filter(pt => {
        if (!selectedPoint) return true;
        return pt.lat !== selectedPoint.lat || pt.lng !== selectedPoint.lng;
      });

      const useCluster = !isFiltering && (pointsToCluster.length > CLUSTER_THRESHOLD || zoom <= CLUSTER_ZOOM_ON);

      if (activePt) {
        const marker = new naver.maps.Marker({
          map: mapInstance,
          position: new naver.maps.LatLng(activePt.lat, activePt.lng),
          zIndex: 9999,
          icon: { content: ICON_HOME, anchor: new naver.maps.Point(18,18) }
        });
        marker.__props = activePt.props;
        marker.__coord = { lat: activePt.lat, lng: activePt.lng };
        
        naver.maps.Event.addListener(marker, 'click', () => {
           openSidebar(marker);
           requestRoute(marker);
        });
        markers.push(marker);
      }

      if (useCluster) {
        const proj = mapInstance.getProjection();
        const clusterMap = new Map();
        const gridSize = 80;

        for (const pt of pointsToCluster) {
          const latlng = new naver.maps.LatLng(pt.lat, pt.lng);
          const pixel = proj.fromCoordToOffset(latlng);
          const k = `${Math.floor(pixel.x/gridSize)}_${Math.floor(pixel.y/gridSize)}`;
          if (!clusterMap.has(k)) clusterMap.set(k, { pts:[], sumLat:0, sumLng:0 });
          const c = clusterMap.get(k);
          c.pts.push(pt); c.sumLat+=pt.lat; c.sumLng+=pt.lng;
        }

        clusterMap.forEach(c => {
          const count = c.pts.length;
          const center = new naver.maps.LatLng(c.sumLat/count, c.sumLng/count);
          if (count === 1) {
            createDotMarker(c.pts[0]);
          } else {
            const cm = new naver.maps.Marker({
              map: mapInstance,
              position: center,
              icon: {
                content: `<div style="width:32px;height:32px;background:#1f2937;color:#fff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:12px;box-shadow:0 2px 5px rgba(0,0,0,0.3);">${count}</div>`,
                anchor: new naver.maps.Point(16,16)
              }
            });
            naver.maps.Event.addListener(cm, 'click', () => {
              const nextZoom = Math.min(mapInstance.getZoom() + 2, 17);
              mapInstance.morph(center, nextZoom);
            });
            clusterMarkers.push(cm);
          }
        });
      } else {
        pointsToCluster.forEach(pt => createDotMarker(pt));
      }
      const statusText = isFiltering ? `í•„í„°: ${FILTER_LIMIT}ë¶„ ì´ë‚´ (${viewportPoints.length}ê°œ)` : `ì´ ${POINTS.length.toLocaleString()}ê°œ / í™”ë©´ ${viewportPoints.length}ê°œ`;
      setStatus(statusText); 
    }

    function createDotMarker(pt) {
      const props = pt.props || {};
      const color = (MODE === 'time') ? colorForTime(props.exp_time) : colorForEff(props.efficiency);
      
      const m = new naver.maps.Marker({
        map: mapInstance,
        position: new naver.maps.LatLng(pt.lat, pt.lng),
        icon: {
          content: `<div class="dot" style="background:${color};"></div>`,
          anchor: new naver.maps.Point(5,5)
        }
      });
      m.__props = props;
      m.__coord = { lat: pt.lat, lng: pt.lng };

      naver.maps.Event.addListener(m, 'click', () => {
        selectedPoint = { lat: pt.lat, lng: pt.lng };
        updateVisibleMarkers(); 
        openSidebar(m);
        requestRoute(m);
      });
      markers.push(m);
    }

    // ---------- 5. ê²½ë¡œ ë¡œì§ (â˜… í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©ìœ¼ë¡œ ì™„ì „ êµì²´ â˜…) ----------
    function clearRouteOverlays() {
      routePolylines.forEach(p => p.setMap(null)); routePolylines = [];
      stopMarkers.forEach(m => m.setMap(null)); stopMarkers = [];
    }

    function drawWalkOnlyRoute(originCoord) {
      if (!mapInstance) return;
      clearRouteOverlays();
      const destLatLng = new naver.maps.LatLng(DEST.lat, DEST.lng);
      const originLatLng = new naver.maps.LatLng(originCoord.lat, originCoord.lng);
      const poly = new naver.maps.Polyline({
        map: mapInstance, path: [originLatLng, destLatLng],
        strokeColor: '#111827', strokeOpacity: 0.8, strokeStyle: 'shortdash', strokeWeight: 2
      });
      routePolylines.push(poly);
      fitMapToBounds([originLatLng, destLatLng]);
    }

    // [í•µì‹¬] ë°±ì—”ë“œ ì—†ì´ ODsay ì§ì ‘ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜
    async function requestRoute(marker) {
      const p = marker.__props || {};
      const coord = marker.__coord || {}; 
      
      if ((p.ride || '').toLowerCase() === 'walk' || (p.ride || '').toLowerCase() === 'walk_only') {
        drawWalkOnlyRoute(coord);
        return;
      }
      setStatus("ê²½ë¡œ ê³„ì‚° ì¤‘â€¦ (Front-end Direct)");

      try {
        // 1. ê¸¸ì°¾ê¸° API í˜¸ì¶œ (searchPubTransPathT)
        const searchUrl = `https://api.odsay.com/v1/api/searchPubTransPathT?SX=${coord.lng}&SY=${coord.lat}&EX=${DEST.lng}&EY=${DEST.lat}&OPT=0&SearchPathType=0&apiKey=${encodeURIComponent(ODSAY_KEY)}`;
        const searchRes = await fetch(searchUrl);
        const searchData = await searchRes.json();

        if (searchData.error) throw new Error(JSON.stringify(searchData.error));

        // 2. íŒŒì´ì¬ì— ìˆë˜ 'ìµœì  ê²½ë¡œ ì„ íƒ ë¡œì§'ì„ JSë¡œ êµ¬í˜„
        const bestPath = selectPathForRideJS(searchData, p.ride, p.board, p.drop);
        if (!bestPath) {
             drawWalkOnlyRoute(coord);
             return;
        }

        // 3. ë…¸ì„  ê·¸ë˜í”½ ë°ì´í„° í˜¸ì¶œ (loadLane)
        const mapObj = bestPath.info.mapObj;
        const laneUrl = `https://api.odsay.com/v1/api/loadLane?mapObject=0:0@${mapObj}&apiKey=${encodeURIComponent(ODSAY_KEY)}`;
        const laneRes = await fetch(laneUrl);
        const laneData = await laneRes.json();

        if (laneData.error) throw new Error(JSON.stringify(laneData.error));

        // 4. ê·¸ë¦¬ê¸°
        drawRouteFromLane(laneData, coord, p); 

      } catch (e) {
        console.error("ODsay Error:", e);
        setStatus("ê²½ë¡œ í˜¸ì¶œ ì‹¤íŒ¨: " + e.message);
        drawWalkOnlyRoute(coord);
      }
    }

    // [í•µì‹¬] íŒŒì´ì¬ì˜ score_path_for_ride ë¡œì§ì„ JSë¡œ ë²ˆì—­
    function selectPathForRideJS(data, ride, board, drop) {
        if (!data.result || !data.result.path) return null;
        const paths = data.result.path;
        
        // ê²€ìƒ‰ ì¡°ê±´ì´ ì—†ìœ¼ë©´ ê·¸ëƒ¥ 1ë“± ê²½ë¡œ ë¦¬í„´
        if (!ride && !board && !drop) return paths[0];

        let best = null; // {score, totalTime, path}

        paths.forEach(path => {
            let score = 0;
            const info = path.info;
            const totalTime = info.totalTime;
            const subPaths = path.subPath || [];

            // 1. ride ë§¤ì¹­
            if (ride) {
                const rideNorm = norm(ride);
                for (const sp of subPaths) {
                    if (![1, 2].includes(sp.trafficType)) continue; // 1:ì§€í•˜ì² , 2:ë²„ìŠ¤
                    const lanes = sp.lane || [];
                    for (const lane of lanes) {
                        const candidates = [];
                        if (lane.busNo) candidates.push(lane.busNo);
                        if (lane.name) candidates.push(lane.name);
                        
                        let hit = false;
                        for (const cand of candidates) {
                            if (rideNorm && norm(cand).includes(rideNorm)) {
                                score += 10;
                                hit = true;
                                break;
                            }
                        }
                        if (hit) break;
                    }
                }
            }

            // 2. ì •ë¥˜ì¥ ë§¤ì¹­
            const stationNames = [];
            subPaths.forEach(sp => {
                const list = sp.passStopList || {};
                const stations = list.stations || list.station || [];
                stations.forEach(st => stationNames.push(norm(st.stationName)));
            });

            if (board && stationNames.some(s => s.includes(norm(board)))) score += 5;
            if (drop && stationNames.some(s => s.includes(norm(drop)))) score += 5;

            // ìµœê³  ì ìˆ˜ ê°±ì‹  (ë™ì ì´ë©´ ì‹œê°„ ì§§ì€ ìˆœ)
            if (best === null || score > best.score || (score === best.score && totalTime < best.totalTime)) {
                best = { score, totalTime, path };
            }
        });

        return best ? best.path : paths[0];
    }

    function norm(s) {
        if (!s) return "";
        return String(s).replace(/[() ë²ˆ]/g, "").trim();
    }

    function drawRouteFromLane(data, originCoord, props) {
      if (!mapInstance) return;
      clearRouteOverlays();

      if (!data || !data.result || !Array.isArray(data.result.lane)) {
        drawWalkOnlyRoute(originCoord);
        return;
      }

      const result = data.result;
      const polyPaths = [];
      const stationLatLngs = [];
      const stationNames   = [];
      const allStations = [];
      
      let allPointsForBounds = [];
      const originLatLng = new naver.maps.LatLng(originCoord.lat, originCoord.lng);
      const destLatLng   = new naver.maps.LatLng(DEST.lat, DEST.lng);
      allPointsForBounds.push(originLatLng, destLatLng);

      let firstRoutePoint = null;
      let lastRoutePoint  = null;

      for (const lane of result.lane) {
        const sections = lane.section || [];
        for (const section of sections) {
          const graphPos = section.graphPos || [];
          const path = [];

          for (const gp of graphPos) {
            const x = Number(gp.x);
            const y = Number(gp.y);
            if (isNaN(x) || isNaN(y)) continue;
            const latlng = new naver.maps.LatLng(y, x);
            path.push(latlng);
            allPointsForBounds.push(latlng);

            if (!firstRoutePoint) firstRoutePoint = latlng;
            lastRoutePoint = latlng;
          }

          if (path.length >= 2) {
            polyPaths.push(path);
          }

          const stations = section.station || [];
          for (const st of stations) {
            const sx = Number(st.x);
            const sy = Number(st.y);
            if (isNaN(sx) || isNaN(sy)) continue;
            const latlng = new naver.maps.LatLng(sy, sx);
            stationLatLngs.push(latlng);
            stationNames.push(st.stationName || '');
            allStations.push({ latlng, name: st.stationName || '' });
          }
        }
      }

      for (const path of polyPaths) {
        const pl = new naver.maps.Polyline({
          map: mapInstance, path,
          strokeColor: '#2563eb', strokeWeight: 3, strokeOpacity: 0.9
        });
        routePolylines.push(pl);
      }

      for (let i = 0; i < stationLatLngs.length; i++) {
        const marker = new naver.maps.Marker({
          map: mapInstance, position: stationLatLngs[i],
          icon: { content: '<div class="stop-dot"></div>', anchor: new naver.maps.Point(4,4) },
          title: stationNames[i]
        });
        stopMarkers.push(marker);
      }

      let boardLatLng = firstRoutePoint; 
      let dropLatLng  = lastRoutePoint;
      let finalBoardName = (props?.board || '').trim();
      let finalDropName  = (props?.drop || '').trim();

      if (allStations.length) {
        if (finalBoardName) {
          const foundBoard = allStations.find(s => (s.name || '').includes(finalBoardName));
          if (foundBoard) {finalBoardName = foundBoard.name;}
        }
        if (finalDropName) {
          const rev = [...allStations].reverse();
          const foundDrop = rev.find(s => (s.name || '').includes(finalDropName));
          if (foundDrop) {finalDropName = foundDrop.name;}
        }
      }

      if (boardLatLng) {
        const walk1 = new naver.maps.Polyline({
          map: mapInstance, path: [originLatLng, boardLatLng],
          strokeColor: '#111827', strokeOpacity: 0.8, strokeStyle: [4, 6], strokeWeight: 2
        });
        routePolylines.push(walk1);

        const boardMarker = new naver.maps.Marker({
          map: mapInstance, position: boardLatLng, zIndex: 1000,
          icon: {
            content: `
                <div class="station-root-dot" style="border-color: #2563eb;">
                    <div class="station-label board">${finalBoardName} ìŠ¹ì°¨</div>
                </div>
            `,
            anchor: new naver.maps.Point(8, 8)
          },
        });
        stopMarkers.push(boardMarker);
      }

      if (dropLatLng) {
        const walk2 = new naver.maps.Polyline({
          map: mapInstance, path: [dropLatLng, destLatLng],
          strokeColor: '#111827', strokeOpacity: 0.8, strokeStyle: [4, 6], strokeWeight: 2
        });
        routePolylines.push(walk2);

        const dropMarker = new naver.maps.Marker({
          map: mapInstance, position: dropLatLng, zIndex: 1000,
          icon: {
            content: `
                <div class="station-root-dot" style="border-color: #ef4444;">
                    <div class="station-label drop">${finalDropName} í•˜ì°¨</div>
                </div>
            `,
            anchor: new naver.maps.Point(8, 8)
          },
        });
        stopMarkers.push(dropMarker);
      }
      fitMapToBounds(allPointsForBounds);
      setStatus("ê²½ë¡œ í‘œì‹œ ì™„ë£Œ");
    }

    // ---------- 6. ë¡œë“œ ë° ì´ˆê¸°í™” (ê¸°ì¡´ê³¼ ë™ì¼) ----------
    async function loadData() {
      try {
        const res = await fetch(DATA_URL);
        const json = await res.json();
        DATA = json;
        EFF_BREAKS = computeEffBreaks(DATA);
        POINTS = [];
        (DATA.features||[]).forEach(f => {
          if(f.geometry?.type==='Point') {
            const [lng, lat] = f.geometry.coordinates;
            const props = {...f.properties, lat, lng};
            if(props.exp_time && props.price_per_py_m && !props.efficiency) {
              props.efficiency = props.exp_time / props.price_per_py_m;
            }
            POINTS.push({lat, lng, props});
          }
        });
        applyMode();
      } catch(e) {
        console.error(e);
        setStatus("ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨");
      }
    }

    function initMap() {
      const map = new naver.maps.Map('map', {
        center: new naver.maps.LatLng(DEST.lat, DEST.lng),
        zoom: 14, scaleControl: false, logoControl: false, mapDataControl: false,
      });
      mapInstance = map;

      new naver.maps.Marker({
        map, position: new naver.maps.LatLng(DEST.lat, DEST.lng),
        title: 'ë„ì„œê´€',
        icon: { content: '<div style="font-size:20px;">ğŸ«</div>', anchor: new naver.maps.Point(10,10) }
      });

      naver.maps.Event.addListener(map, 'idle', updateVisibleMarkers);
      naver.maps.Event.addListener(map, 'click', () => { closeSidebar(); });

      document.getElementById('btn-time').addEventListener('click', ()=>{ MODE='time'; applyMode(); });
      document.getElementById('btn-eff').addEventListener('click', ()=>{ MODE='eff'; applyMode(); });

      const filterCtrl = document.getElementById('filter-control');
      const slider = document.getElementById('time-slider');
      const label = document.getElementById('filter-val-label');

      if (filterCtrl && slider) {
        filterCtrl.addEventListener('click', (e) => {
           if (e.target === slider) return;
           filterCtrl.classList.toggle('expanded');
        });
        slider.addEventListener('input', (e) => {
           const val = Number(e.target.value);
           FILTER_LIMIT = val; 
           label.textContent = (val === 60) ? 'ì „ì²´' : `${val}ë¶„`;
           updateVisibleMarkers();
        });
      }
      loadData();
    }
  </script>
